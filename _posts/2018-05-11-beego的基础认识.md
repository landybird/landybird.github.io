---
title: beego的基础认识
description: beego的基础认识
categories:
- go
tags:
- beego
---

<br>


# beego的基础认识

`beego` 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发  API、Web 及后端服务等各种应用，是一个 RESTful 的框架

    主要设计灵感来源于 tornado、sinatra 和 flask 这三个框架，但是结合了 Go 本身的一些特性（interface、struct 嵌入等）而设计的一个框架


<br>

## 1 beego的特点


| 特点 | 举例 |
| --- | --- | 
| 简单化 | RESTful 支持、 MVC 模型，可以使用 bee 工具快速地开发应用，包括监控代码修改进行热编译、自动化测试代码以及自动化打包部署。 |
| 智能化 | 支持智能路由、智能监控，可以监控 QPS、内存消耗、CPU 使用，以及 goroutine 的运行状况，让您的线上应用尽在掌握。 |
| 高性能 | beego 采用了 Go 原生的 http 包来处理请求，goroutine 的并发效率足以应付大流量的 Web 应用和 API 应用，目前已经应用于大量高并发的产品中。 | 


<br>

## 2 beego的架构



 ![](https://landybird.github.io/landybird.github.io/assets/images/beego1.png)

`beego 是基于八大独立的模块构建的，是一个高度解耦的框架。`

当初设计 beego 的时候就是考虑功能模块化，用户即使不使用 beego 的 HTTP 逻辑，也依旧 可以使用这些独立模块

    例如：
    
    使用 cache 模块来做你的缓存逻辑；
    使用日志模块来记录你的操作信息；
    使用 config 模块来解析你各种格式的文件。
    
所以 beego 不仅可以用于 HTTP 类的应用开发，在你的 socket 游戏开发中也是很有用的模块，这也是 beego 为什么受欢迎的一个原因。


<br>

## 3 beego 的执行逻辑

 ![](https://landybird.github.io/landybird.github.io/assets/images/beego2.png)


<br>

## 4 beego 的项目结构


    一般的 beego 项目的目录如下所示：
    
        ├── conf
        │   └── app.conf
        ├── controllers
        │   ├── admin
        │   └── default.go
        ├── main.go
        ├── models
        │   └── models.go
        ├── static
        │   ├── css
        │   ├── ico
        │   ├── img
        │   └── js
        └── views
            ├── admin
            └── index.tpl

从上面的目录结构我们可以看出来 M（models 目录）、V（views 目录）和 C（controllers 目录）的结构， main.go 是入口文件。


<br>

## 5 Beego 项目的完整流程


beego 是一个典型的 `MVC 框架`，它的整个执行逻辑如下:

 ![](https://landybird.github.io/landybird.github.io/assets/images/beego3.png)


    在监听的端口接收数据，默认监听在 8080 端口。
    
    用户请求到达 8080 端口之后进入 beego 的处理逻辑。
    
    初始化 Context 对象，根据请求判断是否为 WebSocket 请求，如果是的话设置 Input，同时判断请求的方法是否在标准请求方法中（GET、POST、PUT、DELETE、PATCH、OPTIONS、HEAD），防止用户的恶意伪造请求攻击造成不必要的影响。
    
    执行 BeforeRouter 过滤器，当然在 beego 里面有开关设置。如果用户设置了过滤器，那么该开关打开，这样可以提高在没有开启过滤器的情况下提高执行效率。如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。
    
    开始执行静态文件的处理，查看用户的请求 URL 是否和注册在静态文件处理 StaticDir 中的 prefix 是否匹配。如果匹配的话，采用 http 包中默认的 ServeFile 来处理静态文件。
    
    如果不是静态文件开始初始化 session 模块(如果开启 session 的话)，这个里面大家需要注意，如果你的 BeforeRouter 过滤器用到了 session 就会报错，你应该把它加入到 AfterStatic 过滤器中。
    
    开始执行 AfterStatic 过滤器，如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。
    
    执行过过滤器之后，开始从固定的路由规则中查找和请求 URL 相匹配的对象。这个匹配是全匹配规则，即如果用户请求的 URL 是 /hello/world，那么固定规则中 /hello 是不会匹配的，只有完全匹配才算匹配。如果匹配的话就进入逻辑执行，如果不匹配进入下一环节的正则匹配。
    
    正则匹配是进行正则的全匹配，这个正则是按照用户添加 beego 路由顺序来进行匹配的，也就是说，如果你在添加路由的时候你的顺序影响你的匹配。和固定匹配一样，如果匹配的话就进行逻辑执行，如果不匹配进入 Auto 匹配。
    
    如果用户注册了 AutoRouter，那么会通过 controller/method 这样的方式去查找对应的 Controller 和他内置的方法，如果找到就开始执行逻辑，如果找不到就跳转到监控判断。
    
    如果找到 Controller 的话，那么就开始执行逻辑，首先执行 BeforeExec 过滤器，如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。
    
    Controller 开始执行 Init 函数，初始化基本的一些信息，这个函数一般都是 beego.Controller 的初始化，不建议用户继承的时候修改该函数。
    
    是否开启了 XSRF，开启的话就调用 Controller 的 XsrfToken，然后如果是 POST 请求就调用 CheckXsrfCookie 方法。
    
    继续执行 Controller 的 Prepare 函数，这个函数一般是预留给用户的，用来做 Controller 里面的一些参数初始化之类的工作。如果在初始化中 responseWriter 有输出，那么就直接进入 Finish 函数逻辑。
    
    如果没有输出的话，那么根据用户注册的方法执行相应的逻辑，如果用户没有注册，那么就调用 http.Method 对应的方法（Get/Post 等）。执行相应的逻辑，例如数据读取，数据赋值，模板显示之类的，或者直接输出 JSON 或者 XML。
    
    如果 responseWriter 没有输出，那么就调用 Render 函数进行模板输出。
    
    执行 Controller 的 Finish 函数，这个函数是预留给用户用来重写的，用于释放一些资源。释放在 Init 中初始化的信息数据。
    
    执行 AfterExec 过滤器，如果有输出的话就跳转到监控判断逻辑。
    
    执行 Controller 的 Destructor，用于释放 Init 中初始化的一些数据。
    
    如果这一路执行下来都没有找到路由，那么会调用 404 显示找不到该页面。
    
    最后所有的逻辑都汇聚到了监控判断，如果用户开启了监控模块（默认是开启一个 8088 端口用于进程内监控），这样就会把访问的请求链接扔给监控程序去记录当前访问的 QPS，对应的链接访问的执行时间，请求链接等。


