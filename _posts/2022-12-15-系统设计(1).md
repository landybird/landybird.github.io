---
title: System Design 系统设计 (1)
description: 了解如何大规模设计系统并准备系统设计面试
categories:
- System Design
tags:
- System Design
---


<br>


> 原文引用 -- [System Design](https://kps.hashnode.dev/system-design-the-complete-course#heading-domain-name-system-dns)

<br>


# 开始

---

<br>

## 什么是系统设计？

> 系统设计是为满足特定要求的系统，定义体系结构、接口和数据的过程。

系统设计通过连贯高效的系统满足业务或组织的需求,
它需要一种系统的方法来构建, 一个好的系统设计需要我们考虑一切，
从基础设施一直到数据及其存储方式。


## 为什么系统设计如此重要？

系统设计帮助我们定义满足业务需求的解决方案。
这是我们在构建系统时可以做出的最早决定之一。

通常必须从高层次思考，因为这些决定以后很难纠正。

随着系统的发展，它还可以更轻松地推理和管理架构更改。



<br>



# Chapter I 基础概念




---

<br>


## IP

`IP 地址`是在 Internet 或本地网络上`标识设备的唯一地址`。
IP 代表“互联网协议”，它是管理通过互联网或本地网络发送的数据格式的一组规则。

本质上，`IP 地址` 是允许信息在网络上的设备之间发送的标识符。
它们包含位置信息并使设备可访问以进行通信。 互联网需要一种方法来区分不同的计算机、路由器和网站。
IP 地址提供了一种这样做的方式，并构成了互联网工作方式的重要组成部分。


### Versions  版本


#### `IPv4`

最初的互联网协议是 IPv4，它使用 32 位数字点十进制表示法，只允许大约 40 亿个 IP 地址。

最初，它绰绰有余，但随着互联网普及率的增长，我们需要更好的东西。

    示例：102.22.192.181

#### `IPv6`

IPv6 是 1998 年引入的新协议。
部署始于 2000 年代中期，并且由于互联网用户呈指数级增长，它仍在进行中。

这个新协议使用 128 位字母数字十六进制表示法。 这意味着 IPv6 可以提供大约 ~340e+36  个 IP 地址。

这足以满足未来几年不断增长的需求。

    示例：2001:0db8:85a3:0000:0000:8a2e:0370:7334


###  Types 类型


####  Public

`公共 IP 地址`是一个主地址与您的整个网络相关联的地址。
在这种类型的 IP 地址中，每个连接的设备都具有相同的 IP 地址。

    示例：ISP 提供给您的路由器的 IP 地址

####  Private

`私有 IP 地址`是分配给连接到互联网网络的每台设备的唯一 IP 编号，其中包括您家中使用的计算机、平板电脑和智能手机等设备。

    示例：您的家庭路由器为您的设备生成的 IP 地址。

#### Static

`静态 IP 地址`不会改变，是手动创建的，而不是已分配的。

这些地址通常更昂贵但更可靠。

    示例：它们通常用于重要的事情，例如可靠的地理位置服务、远程访问、服务器托管等。

#### Dynamic

`动态 IP 地址`会不时更改，并不总是相同。 它已由动态主机配置协议 (DHCP) 服务器分配。
动态 IP 地址是最常见的互联网协议地址类型。
它们的部署成本更低，并允许我们根据需要在网络中重复使用 IP 地址。

    示例：它们更常用于消费设备和个人用途。




<br>


## OSI模型

`OSI 模型`是一种逻辑和概念模型，它定义了系统所使用的网络通信，这些系统对与其他系统的互连和通信开放。

开放系统互连（OSI 模型）还定义了一个逻辑网络，并通过使用各种协议层有效地描述了`计算机数据包传输`。

`OSI 模型可以看作是计算机网络的通用语言`。

它基于将通信系统分成`七个抽象层`的概念，每个抽象层堆叠在最后一个之上。


### 为什么 `OSI 模型`很重要？

`开放系统互连 (OSI) 模型`定义了网络讨论和文档中使用的通用术语。

这使我们能够将`非常复杂的通信过程`分开并评估其组成部分。

虽然这个模型没有直接在当今最常见的 `TCP/IP 网络`中实现，但它仍然可以帮助我们做更多的事情，比如:

    简化故障排除并帮助识别整个堆栈中的威胁。 
    
    鼓励硬件制造商创建可以通过网络相互通信的网络产品。
    
    对于培养安全第一的心态至关重要。
    
    将复杂的功能分解为更简单的组件。


###  `OSI 模型`的七个抽象层 `Layers` (从上到下)


####  应用 Application

`这是唯一直接与用户数据交互的层`

Web 浏览器和电子邮件客户端等软件应用程序依赖`应用程序层`来启动通信。

但应该明确的是，客户端软件应用程序不是应用程序层的一部分，`应用程序层`负责软件所依赖的协议和数据操作，以向用户提供有意义的数据。

应用层协议包括 `HTTP` 和 `SMTP`。


#### 表示 Presentation

`表示层也称为翻译层`。

来自应用层的数据在这里被提取并按照所需的格式进行操作以通过网络传输。

表示层的功能是`翻译、加密/解密和压缩`


#### 会话 Session

`会话层` 是负责`打开`和`关闭`两个设备之间通信的层。

`通信打开和关闭之间的时间称为会话`。

`会话层`确保会话保持打开足够长的时间以传输所有正在交换的数据，然后及时关闭会话以避免资源浪费。

`会话层`还将数据传输与检查点同步


#### 传输 Transport

`传输层`（也称为第 4 层）负责两个设备之间的端到端通信。

这包括从`会话层`获取数据并将其`分解`为称为段的块，然后再将其发送到网络层（第 3 层）。

它还负责将接收设备上的段`重组`为会话层可以使用的数据。


#### 网络 Network

`网络层`负责促进两个不同网络之间的数据传输。

网络层在发送方设备上将来自传输层的数据段分解为更小的单元（称为`数据包`），并在接收设备上重新组装这些数据包。

网络层还为数据找到到达目的地的最佳物理路径，这称为`路由`。

如果通信的两个设备在`同一网络上`，则不需要网络层。


#### 数据链路 Data Link

`数据链路层`与网络层非常相似，除了数据链路层有助于同一网络上两个设备之间的数据传输。

数据链路层从网络层获取数据包并将它们分成更小的部分，称为`帧`。


#### 物理层 Physical

`物理层`包括数据传输中涉及的物理设备，例如电缆和交换机。

这也是将数据转换为`比特流`的层，比特流是由 1 和 0 组成的字符串。

两个设备的`物理层`还必须就信号约定达成一致，以便可以区分两个设备上的 1 和 0。



<br>





## TCP and UDP


### TCP

传输控制协议 `Transmission Control Protocol` (TCP) 是面向连接的，这意味着一旦建立了连接，就可以双向传输数据。

TCP 具有内置系统来检查错误并保证数据按发送顺序传送，使其成为传输静止图像、数据文件和网页等信息的完美协议。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/tcp-and-udp/tcp.png)

但是，虽然 TCP 本能地可靠，但其`反馈机制`也导致更大的开销，转化为更多地使用网络上的可用带宽。

### UDP

`User Datagram Protocol` 用户数据报协议 (UDP) 是一种更简单的`无连接`互联网协议，其中不需要错误检查和恢复服务。

使用 UDP，没有用于打开连接、维护连接或终止连接的开销。

数据不断发送给接收者，无论他们是否收到。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/tcp-and-udp/udp.png)


对于广播或多播网络传输之类的实时通信，`UDP` 在很大程度上是首选。

当我们需要`最低延迟`并且延迟数据 > 数据丢失 ，我们应该使用 UDP > TCP


### TCP vs UDP


TCP 是一种面向连接的协议，而 UDP 是一种无连接协议。

TCP 和 UDP 之间的一个主要区别是速度，因为 TCP 比 UDP 相对慢。

    总的来说，UDP 是一种更快、更简单、更高效的协议; 但是，只有 TCP 才能重传丢失的数据包。

TCP 提供从用户到服务器的有序数据传输（反之亦然），而 UDP 不专用于端到端通信，也不检查接收方是否准备就绪。


|Feature|TCP|UDP|
|---|---|---|
|`Connection 连接`|需要建立连接|无连接协议|
|`Guaranteed delivery 保证交付`|可以保证数据交付|不能保证数据交付|
|`Re-transmission 重传`|可以重新传输丢失的数据包|可以重新传输丢失的数据包|
|`Speed 速度`|`Slower than UDP`|`Faster than TCP`|
|`Broadcasting 广播`|不支持广播|支持广播|
|`Use cases 用例`|`HTTPS, HTTP, SMTP, POP, FTP, etc`|`Video streaming, DNS, VoIP, etc`|


<br>

## 域名系统 (DNS)

IP 地址，它使每台机器都能与其他机器连接。

但正如我们所知，人类更喜欢名字而不是数字。

像 `google.com` 这样的名字比 `122.250.192.232` 这样的名字更容易记住

这将我们带到了`域名系统 (DNS)`，它是一种分层和分散的命名系统，用于将人类可读的域名转换为 IP 地址



### DNS 如何工作


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/domain-name-system/how-dns-works.png)


DNS 查找包括以下八个步骤:

    客户端在 Web 浏览器中键入 `example.com`，查询传输到 Internet 并由 DNS 解析器接收。
    
    解析器然后递归地查询 DNS 根名称服务器。
    
    根服务器使用顶级域 (TLD) 的地址响应解析器。 
    
    然后，解析器向 .com TLD 发出请求。
    
    TLD 服务器然后使用域名称服务器 example.com 的 IP 地址进行响应。 
    
    最后，递归解析器向域的名称服务器发送查询。 
    
    example.com 的 IP 地址随后从名称服务器返回给解析器。 
    
    然后，DNS 解析器使用最初请求的域的 IP 地址响应 Web 浏览器。

解析 IP 地址后，客户端应该能够从已解析的 IP 地址请求内容。
例如，解析后的IP可能会返回一个网页，在浏览器中呈现


### 构成 DNS 基础设施的四个关键服务器组  Server types


#### DNS 解析器  Resolver

`DNS 解析器`（也称为 DNS 递归解析器）是 DNS 查询的第一站。

递归解析器充当客户端和 DNS 名称服务器之间的中间人。

在从 Web 客户端接收到 DNS 查询后，递归解析器将使用缓存数据进行响应，或者向根名称服务器发送一个请求，然后向 TLD 名称服务器发送另一个请求，然后向权威名称服务器发送最后一个请求。
在从包含请求的 IP 地址的权威名称服务器收到响应后，递归解析器随后向客户端发送响应。


####  DNS 根服务器  Root Server

`根服务器` 接受包含域名的递归解析器查询，根名称服务器根据该域的扩展名（.com、.net、.org 等）通过将递归解析器定向到 TLD 名称服务器进行响应 .).

根名称服务器由名为互联网名称与数字地址分配机构 (ICANN) 的非营利组织监管。

每个递归解析器都知道 13 个 DNS 根名称服务器。

请注意，虽然有 13 个根名称服务器，但这并不意味着根名称服务器系统中只有 13 台机器。

有 13 种类型的根域名服务器，但每一种在世界各地都有多个副本，它们使用 Anycast 路由来提供快速响应。


####  TLD 名称服务器  TLD nameserver

`TLD 名称服务器`维护共享公共域扩展名的所有域名的信息，例如 .com、.net 或 URL 中最后一个点之后的任何名称。

TLD 名称服务器的管理由互联网号码分配机构 (IANA) 负责，它是 ICANN 的一个分支机构。

IANA 将 TLD 服务器分为两个主要组：

- 通用顶级域：这些是 `.com、.org、.net、.edu 和 .gov 等域`。

- 国家代码顶级域：这些包括特定于国家或州的任何域。示例包括 `.uk、.us、.ru 和 .jp`。


#### 权威DNS服务器 Authoritative DNS server

`权威域名服务器`通常是解析器获取 IP 地址的最后一步。

权威名称服务器包含特定于其服务的域名的信息（例如 google.com），并且它可以提供递归解析器，
其中包含在 DNS A 记录中找到的该服务器的 IP 地址，或者如果该域具有 CNAME 记录（别名） 它将为递归解析器提供别名域，
此时递归解析器将必须执行全新的 DNS 查找以从权威名称服务器获取记录（通常是包含 IP 地址的 A 记录）。

如果找不到域，则返回 `NXDOMAIN` 消息


### DNS 系统中存在三种类型的查询  Query Types


#### 递归 Recursive

在递归查询中，DNS 客户端要求 DNS 服务器（通常是 DNS 递归解析器）将使用请求的资源记录或错误消息响应客户端（如果解析器找不到记录）


#### 迭代 Iterative

在迭代查询中，DNS 客户端提供主机名，DNS 解析器返回它所能提供的最佳答案。

如果 DNS 解析器在其缓存中有相关的 DNS 记录，它会返回它们。
如果不是，它会将 DNS 客户端指向根服务器或距离所需 DNS 区域最近的另一个权威名称服务器。
然后 DNS 客户端必须直接对它所引用的 DNS 服务器重复查询。


#### 非递归查询 Non-recursive

非递归查询是 DNS 解析器已经知道答案的查询。

它要么立即返回 DNS 记录，因为它已经将它存储在本地缓存中，要么查询对记录具有权威性的 DNS 名称服务器，
这意味着它肯定拥有该主机名的正确 IP。

在这两种情况下，都不需要额外的查询轮次（如递归或迭代查询）。
相反，响应会立即返回给客户端





### DNS records



DNS 记录（又名区域文件）是权威 DNS 服务器中的指令，
提供有关域的信息，包括与该域相关联的 IP 地址以及如何处理对该域的请求

这些记录由一系列以所谓的 DNS 语法编写的文本文件组成。
DNS 语法只是用作命令的一串字符，告诉 DNS 服务器要做什么

所有 DNS 记录也有一个“TTL”，代表生存时间，表示 DNS 服务器刷新该记录的频率


一些最常用的记录类型：

    A（地址记录）：这是保存域 IP 地址的记录。 
    
    AAAA（IP 版本 6 地址记录）：包含域的 IPv6 地址的记录（与存储 IPv4 地址的 A 记录相反）。 
    
    CNAME（规范名称记录）：将一个域或子域转发到另一个域，不提供 IP 地址。 
    
    MX（邮件交换器记录）：将邮件定向到电子邮件服务器。 
    
    TXT（文本记录）：此记录允许管理员在记录中存储文本注释。 这些记录通常用于电子邮件安全。 
    
    NS（名称服务器记录）：存储 DNS 条目的名称服务器。 
    
    SOA（授权开始）：存储有关域的管理信息。 
    
    SRV（Service Location record）：指定特定服务的端口。 
    
    PTR（Reverse-lookup Pointer records）：在反向查找中提供域名。 
    
    CERT（证书记录）：存储公钥证书。



### Subdomain 子域



子域是我们主域名的附加部分。

它通常用于在逻辑上将网站分成几个部分。

我们可以在主域上创建多个子域或子域。


    例如，blog.example.com，其中 blog 是子域，example 是主域，.com 是顶级域 (TLD)。
    
    类似的示例可以是 support.example.com 或 careers.example.com。



###  DNS Zones DNS 区域



`DNS 区域`是域命名空间的一个独特部分，它被委托给负责维护 DNS 区域的法律实体，如个人、组织或公司。
DNS 区域也是一种管理功能，允许对 DNS 组件（例如权威名称服务器）进行精细控制。




### DNS Caching  DNS 缓存



DNS 缓存（有时称为 DNS 解析器缓存）是一个临时数据库，由计算机的操作系统维护，其中包含所有最近访问和尝试访问网站和其他 Internet 域的记录。
换句话说，DNS 缓存只是最近 DNS 查找的记忆，我们的计算机在试图弄清楚如何加载网站时可以快速参考它。

域名系统对每个 DNS 记录实施生存时间 (TTL)。
TTL 指定 DNS 客户端或服务器可以缓存记录的秒数。
当记录存储在缓存中时，它附带的任何 TTL 值也会被存储。
服务器继续更新缓存中存储的记录的 TTL，每秒倒计时。
当它达到零时，记录将被删除或从缓存中清除。 此时，如果收到对该记录的查询，则 DNS 服务器必须启动解析过程。



### Reverse DNS  反向域名解析



反向 DNS 查找是对与给定 IP 地址关联的域名的 DNS 查询。
这与更常用的正向 DNS 查找相反，后者查询 DNS 系统以返回 IP 地址。
反向解析 IP 地址的过程使用 PTR 记录。 如果服务器没有 PTR 记录，则无法解析反向查找。

电子邮件服务器通常使用反向查找。 电子邮件服务器在将电子邮件发送到其网络之前检查并查看电子邮件消息是否来自有效服务器。
许多电子邮件服务器会拒绝来自任何不支持反向查找的服务器或来自极不可能合法的服务器的邮件。

注意：反向 DNS 查找并未被普遍采用，因为它们对互联网的正常功能并不重要



### 一些广泛使用的托管 DNS 解决方案

    Route53
  
    Cloudflare DNS
  
    Google Cloud DNS
  
    Azure DNS
  
    NS1




<br>

---


<br>


## 负载均衡 Load Balance



`负载均衡`让我们可以在多个资源之间分配传入的网络流量，通过仅向在线资源发送请求来确保高可用性和可靠性,
这提供了根据需求增加或减少资源的灵活性

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/load-balancer.png)

为了获得额外的可扩展性和冗余，我们可以尝试在系统的每一层进行负载平衡

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/load-balancer-layers.png)



### 为什么要用负载均衡？




现代高流量网站必须为来自用户或客户端的数十万（如果不是数百万）并发请求提供服务。
为了经济高效地扩展以满足这些高容量，现代计算最佳实践通常需要添加更多服务器。

负载均衡器可以位于服务器前面，并在所有能够以最大化速度和容量利用率的方式满足这些请求的服务器之间路由客户端请求。
这确保没有单个服务器过度工作，这可能会降低性能。
如果单个服务器出现故障，负载均衡器会将流量重定向到其余在线服务器。
将新服务器添加到服务器组时，负载均衡器会自动开始向其发送请求

    负载平衡在防止停机方面也起着关键作用，

      负载平衡的其他优势包括： 

        可扩展性 
  
        冗余 
        
        灵活性 
        
        效率



### 工作负载分配  Workload distribution

这是负载均衡器提供的`核心功能`

有几个常见的变体：


    基于主机：根据请求的主机名分配请求。 
    
    基于路径：使用整个 URL 来分发请求，而不是仅仅使用主机名。 
    
    基于内容：检查请求的消息内容。 这允许基于诸如参数值之类的内容进行分发。



### 负载均衡器在 网络传输层 运行的级别



一般来说，负载均衡器在两个级别之一运行：

- `网络层` 这是在网络传输层（也称为第 4 层）工作的负载均衡器。
  它根据 IP 地址等网络信息执行路由，并且无法 执行基于内容的路由。
  这些通常是可以高速运行的专用硬件设备。

- `应用层` 这是在应用层（也称为第 7 层）运行的负载均衡器。
  负载均衡器可以完整读取请求并执行基于内容的路由。
  这允许基于对流量的全面了解来管理负载。


### 不同类型的负载均衡器


#### `Software` 软件负载平衡器

软件负载平衡器通常比硬件版本更容易部署。

它们也往往更具成本效益和灵活性，并且它们与软件开发环境结合使用。
软件方法使我们能够根据环境的特定需求灵活地配置负载平衡器。

灵活性的提升可能是以必须做更多工作来设置负载均衡器为代价的。

与提供更多封闭式方法的硬件版本相比，软件平衡器为我们提供了更多更改和升级的自由。

软件负载平衡器被广泛使用，既可以作为需要配置和管理的可安装解决方案使用，也可以作为托管云服务使用。

#### `Hardware` 硬件负载均衡器

硬件负载均衡器依赖物理的本地硬件来分配应用程序和网络流量。

这些设备可以处理大量流量，但通常价格不菲，而且在灵活性方面相当有限。

硬件负载平衡器包括专有固件，需要在发布新版本和安全补丁时进行维护和更新。

#### `DNS` DNS 负载平衡

DNS 负载平衡是在域名系统 (DNS) 中配置域的做法，以便客户端对域的请求分布在一组服务器计算机上。

不幸的是，DNS 负载平衡存在限制其可靠性和效率的固有问题。

最重要的是，DNS 不会检查服务器和网络中断或错误。

它总是为域返回同一组 IP 地址，即使服务器已关闭或无法访问也是如此。


### Routing Algorithms 路由算法


- `Round-robin`：请求轮流分发给应用服务器。

- `Weighted Round-robin`：建立在简单的 Round-robin 技术之上，使用管理员通过 DNS 记录分配的权重来考虑不同的服务器特性，例如计算和流量处理能力。

- `最少连接`：新请求发送到当前与客户端的连接最少的服务器。
  每台服务器的相对计算能力是确定哪台服务器连接最少的因素。

- `最短响应时间`：将请求发送到根据组合了最快响应时间和最少活动连接的公式选择的服务器。

- `最小带宽`：此方法以每秒兆位 (Mbps) 为单位测量流量，将客户端请求发送到流量最少 Mbps 的服务器。

- `散列`：根据我们定义的密钥分发请求，例如客户端 IP 地址或请求 URL。


### 冗余负载平衡器  Redundant load balancers

负载均衡器本身可能是单点故障。

为了克服这个问题，可以在集群模式下使用第二个或 N 个负载平衡器。

而且，如果有故障检测并且主动负载均衡器发生故障，另一个被动负载均衡器可以接管，这将使我们的系统更具容错性。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/redundant-load-balancer.png)


### 负载均衡器的一些常见功能


    自动缩放：根据需求情况启动和关闭资源。 
    
    粘性会话：将同一用户或设备分配给同一资源以维护资源上的会话状态的能力。 
    
    Healthchecks：确定资源是否关闭或性能不佳以便从负载平衡池中删除资源的能力。 
    
    持久连接：允许服务器打开与客户端（例如 WebSocket）的持久连接。 
    
    加密：处理加密连接，例如 TLS 和 SSL。 
    
    证书：向客户端出示证书并验证客户端证书。 
    
    压缩：压缩响应。 
    
    缓存：应用层负载均衡器可以提供缓存响应的能力。 
    
    日志记录：请求和响应元数据的日志记录可以用作重要的审计跟踪或分析数据的来源。 
    
    请求跟踪：为每个请求分配一个唯一的 ID，用于记录、监控和故障排除。 
    
    重定向：根据请求路径等因素重定向传入请求的能力。 
    
    固定响应：返回请求的静态响应，例如错误消息。




<br>


---


<br>


## Clustering 集群

在高层次上，`计算机集群`是一组两台或多台计算机或节点，它们`并行运行`以`实现共同目标`。

这允许由大量独立的、可并行的任务组成的工作负载分布在集群中的节点之间。

因此，这些任务可以利用每台计算机的组合内存和处理能力来提高整体性能。

要构建计算机集群，各个节点应连接到网络以启用节点间通信。

然后可以使用该软件将节点连接在一起并形成集群。 它可能在每个节点上都有一个共享存储设备和/或本地存储

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/cluster.png)


通常，至少有一个节点被指定为`领导节点`，并充当集群的`入口点`。
领导节点可能负责将传入的工作委派给其他节点，并在必要时聚合结果并将响应返回给用户。

理想情况下，一个集群就像一个单独的系统一样运行。
访问集群的用户不需要知道系统是集群还是单独的机器。
此外，集群的设计应尽量减少延迟并防止节点到节点通信中的瓶颈


### 集群计算的四个关键优势


    高可用性 

    可扩展性 
    
    性能 
    
    高性价比


###  计算机集群通常可以分为三种类型

    Highly available or fail-over  高可用性或故障转移  

    Load balancing  负载均衡

    High-performance computing  高性能计算


### 两种最常用的高可用性 (HA) 集群配置



#### Active-Active 双活


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/active-active.png)


`双活集群`通常由至少两个节点组成，两个节点同时主动运行相同类型的服务。

双活集群的主要目的是实现`负载均衡`。

负载均衡器将工作负载分配到所有节点，以防止任何单个节点过载。
因为有更多节点可供服务，吞吐量和响应时间也会有所改善。



#### Active-Passive 主动-被动

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/active-passive.png)

与主动-主动集群配置一样，主动-被动集群也由至少两个节点组成。
但是，正如名称主动-被动所暗示的那样，并非所有节点都将处于活动状态。
例如，在有两个节点的情况下，如果第一个节点已经处于活动状态，则第二个节点必须处于被动状态或处于备用状态。


### 负载平衡与集群

负载平衡与集群有一些共同的特征，但它们是不同的过程。

集群提供冗余并提高容量和可用性。 集群中的服务器相互了解并为共同的目的协同工作。

但是通过负载平衡，服务器之间并不知道彼此。 相反，他们对从负载均衡器收到的请求做出反应。
我们可以将负载平衡与集群结合使用，但它也适用于涉及具有共同目的的独立服务器的情况，例如运行网站、业务应用程序、Web 服务或其他一些 IT 资源。


### 集群的复杂性


集群带来的最明显的挑战是安装和维护的复杂性增加。
必须在每个节点上分别安装和更新操作系统、应用程序及其依赖项。

如果集群中的节点不是同类的，这会变得更加复杂。 还必须密切监视每个节点的资源利用率，并汇总日志以确保软件运行正常。

此外，存储变得更难管理，共享存储设备必须防止节点相互覆盖，分布式数据存储必须保持同步。


<br>



## Caching 缓存


`缓存`的主要目的是通过减少访问底层较慢存储层的需要来`提高数据检索性能`。

`以容量换取速度`，缓存通常会暂时存储数据的子集，这与数据通常是完整且持久的数据库不同。

缓存利用了局部引用原则 “`最近请求的数据很可能会被再次请求`”。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/caching.png)


###  缓存和内存

类似于计算机的内存，高速缓存是一种紧凑、快速的内存，它以层次结构存储数据，
从第一层开始，然后从那里按顺序进行。 它们被标记为 L1、L2、L3 等。
如果请求，缓存也会被写入，例如当有更新并且需要将新内容保存到缓存中时，替换已保存的旧内容。

无论缓存是读还是写，都是一次一个块地完成。 每个块还有一个标签，其中包含数据在缓存中的存储位置。
当从缓存中请求数据时，会通过标签进行搜索，以查找内存一级 (L1) 中所需的特定内容。
如果未找到正确的数据，则会在 L2 中进行更多搜索。

如果在那里找不到数据，则在 L3 中继续搜索，然后是 L4，依此类推，直到找到为止，然后读取并加载它。
如果在缓存中根本找不到数据，则会将其写入缓存中以便下次快速检索。


### 缓存命中和缓存未命中


#### 缓存命中

`缓存命中`描述了从缓存中成功提供内容的情况。
标签在内存中快速搜索，当找到并读取数据时，它被认为是缓存命中。

> 冷缓存、温缓存和热缓存

缓存命中也可以描述为`冷缓存、温缓存或热缓存`。 在每一个中，都描述了读取数据的速度。

`热缓存`是以尽可能快的速度从内存中读取数据的实例。
当从 L1 检索数据时会发生这种情况。

`冷缓存`是读取数据的最慢速率，但它仍然是成功的，因此仍被视为缓存命中。
数据只是在内存层次结构中较低的位置（例如 L3 或更低）中找到。

`暖缓存`用于描述在 L2 或 L3 中找到的数据。 它不如热缓存快，但仍然比冷缓存快。
通常，将缓存称为暖缓存用于表示它比热缓存更慢且更接近冷缓存。


#### 缓存未命中

缓存未命中是指搜索内存但找不到数据的实例。发生这种情况时，内容将被传输并写入缓存。



###  缓存失效

`缓存失效`是计算机系统将缓存条目声明为无效并删除或替换它们的过程。

如果数据被修改，它应该在缓存中失效，否则，这会导致不一致的应用程序行为。

三种缓存系统

#### Write-through cache 直写缓存

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-through-cache.png)


数据`同时`写入缓存和对应的数据库。


    优点：快速检索，缓存和存储之间的数据完全一致
    
    缺点：写入操作的延迟更高。


#### Write-around cache 饶写缓存

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-around-cache.png)

直接写到数据库或永久存储的地方，绕过缓存。

    优点：这可能会减少延迟。
    
    缺点：它增加了缓存未命中，因为缓存系统必须在缓存未命中的情况下从数据库中读取信息。 
         因此，对于快速写入和重新读取信息的应用程序，这可能会导致更高的读取延迟。 
         读取发生在较慢的后端存储中，并经历较高的延迟。


#### Write-back cache 回写缓存

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-back-cache.png)

其中只对缓存层进行写入，写入缓存完成后立即确认写入。 然后缓存将此写入异步同步到数据库。

    优点：这将减少写入密集型应用程序的延迟并提高吞吐量。 
    
    缺点：如果缓存层崩溃，则存在数据丢失的风险。 
        我们可以通过让多个副本确认缓存中的写入来改进这一点。




<br>




## Content Delivery Network (CDN)  内容分发网络 (CDN)


内容分发网络 (CDN) 是一组地理分布的服务器，它们协同工作以提供 Internet 内容的快速分发。
通常，HTML/CSS/JS、照片和视频等静态文件由 CDN 提供

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/content-delivery-network/cdn-map.png)



### 为什么要使用 CDN?


内容交付网络 (CDN) 提高了内容可用性和冗余度，同时降低了带宽成本并提高了安全性。

从 CDN 提供内容可以显着提高性能，因为用户从靠近他们的数据中心接收内容，而我们的服务器不必为 CDN 满足的请求提供服务。



### CDN 工作模式

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/content-delivery-network/cdn.png)

在 CDN 中，源服务器包含内容的原始版本，而边缘服务器数量众多，分布在世界各地。

为了最大程度地缩短访问者与网站服务器之间的距离，CDN 将其内容的缓存版本存储在多个称为边缘位置的地理位置。

每个边缘位置都包含许多缓存服务器，负责向其附近的访问者提供内容。

一旦静态资产缓存在特定位置的所有 CDN 服务器上，所有后续网站访问者对静态资产的请求都将从这些边缘服务器而不是源站传递，从而减少源站负载并提高可扩展性。

    例如，当英国的某个人请求我们可能在美国托管的网站时，他们将从最近的边缘位置（例如伦敦边缘位置）获得服务。 
    这比让访问者向源服务器发出完整请求要快得多，后者会增加延迟。


### CDN一般分为两种：



#### Push CDNs

每当服务器上发生更改时，推送 CDN 都会接收新内容。
我们全权负责提供内容，直接上传到 CDN，重写 URL 指向 CDN。
我们可以配置内容何时过期以及何时更新。 仅当内容是新的或更改时才上传，最大限度地减少流量，但最大限度地增加存储空间。
具有少量流量的站点或内容不经常更新的站点与推送 CDN 配合得很好。
内容只放置在 CDN 上一次，而不是定期重新拉取。


#### Pull CDN

在拉取 CDN 的情况下，缓存根据请求进行更新。
当客户端发送一个请求，要求从 CDN 获取静态资源，如果 CDN 没有，那么它会从源服务器获取新更新的资源，
并用这个新资源填充它的缓存，然后发送这个 新的缓存资产给用户。
与 Push CDN 相反，这需要较少的维护，因为 CDN 节点上的缓存更新是根据客户端对源服务器的请求执行的。
流量大的站点与拉取式 CDN 配合得很好，因为流量分布更均匀，只有最近请求的内容保留在 CDN 上。


###  缺点

众所周知，好事伴随着额外的成本，所以让我们讨论一下 CDN 的一些缺点：

    额外费用：使用 CDN 可能很昂贵，尤其是对于高流量服务。 
    
    限制：一些组织和国家已经阻止了流行的 CDN 的域或 IP 地址。 
    
    位置：如果我们的大多数观众位于 CDN 没有服务器的国家/地区，则我们网站上的数据可能需要比不使用任何 CDN 时传输得更远。



<br>



## Proxy 代理

`代理服务器`是位于客户端和后端服务器之间的`硬件/软件中间件`。

它接收来自客户端的请求并将它们中继到源服务器。

通常，代理用于`过滤请求`、`记录请求`或有时`转换请求（通过添加/删除标头、加密/解密或压缩）`。


### 两种类型的代理


#### Forward Proxy 正向代理

`正向代理`通常称为代理、代理服务器或 Web 代理，是位于一组客户端计算机前面的服务器。

当这些计算机向 Internet 上的站点和服务发出请求时，代理服务器会拦截这些请求，然后像中间人一样代表这些客户端与 Web 服务器通信。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/proxy/forward-proxy.png)


正向代理的一些优点：

    阻止访问某些内容 
    
    允许访问受地理限制的内容 
    
    提供匿名性 
    
    避免其他浏览限制 

尽管代理提供匿名的好处，但它们仍然可以跟踪我们的个人信息。 代理服务器的设置和维护成本高昂且需要配置


#### Reverse Proxy 反向代理


`反向代理`是位于一个或多个 Web 服务器前面的服务器，拦截来自客户端的请求。

当客户端向网站的源站服务器发送请求时，这些请求会被反向代理服务器拦截。


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/proxy/reverse-proxy.png)


反向代理的一些优点：

    提高安全性 
    
    缓存 
    
    SSL加密 
    
    负载均衡 
    
    可扩展性和灵活性


### 负载均衡器 vs 反向代理


当我们有多个服务器时，负载均衡器很有用。

通常，负载平衡器将流量路由到一组服务相同功能的服务器，而反向代理即使只有一个 Web 服务器或应用程序服务器也很有用。

反向代理也可以充当负载均衡器，但反之则不行





<br>




## Availability  可用性

`可用性`是系统在特定时期内保持运行以执行其所需功能的时间。
它是对系统、服务或机器在正常条件下保持运行的时间百分比的简单度量。


如果可用性为 99.00%，则称其可用性为“2 个 9”，如果为 99.9%，则称为“3 个 9”，依此类推。

<br>

---


<br>




## Scalability  可扩展性

`可扩展性`是衡量系统通过添加或删除资源来满足需求来响应变化的能力。


### Vertical scaling  垂直缩放

垂直扩展（也称为向上扩展）通过为现有机器增加更多功能来扩展系统的可扩展性。
换句话说，垂直扩展是指通过`增加硬件容量`来提高应用程序的能力。

优点

    易于实施
    更易于管理
    数据一致
    缺点
    停机时间长的风险
    更难升级
    可能是单点故障



### Horizontal scaling 水平缩放


水平扩展（也称为向外扩展）通过添加更多机器来扩展系统的规模。
它通过向现有服务器池`添加更多实例`来提高服务器性能，从而使负载分布更均匀。

优点

    增加冗余
    更好的容错能力
    灵活高效
    更容易升级
    缺点
    增加复杂性
    数据不一致
    增加下游服务的负载



<br>

---


<br>



##  Storage  存储

`存储`是一种使系统能够临时或永久保留数据的机制。



### RAID

RAID (Redundant Array of Independent Disks)（独立磁盘冗余阵列）是一种将相同数据存储在多个硬盘或固态驱动器
(SSD) 上以在驱动器发生故障时保护数据的方法。


> 一些常用的 RAID 级别:

    RAID 0：也称为条带化，数据在阵列中的所有驱动器之间平均分配。
    
    RAID 1：也称为镜像，至少两个驱动器包含一组数据的精确副本。 如果一个驱动器出现故障，其他驱动器仍然可以工作。
    
    RAID 5：带奇偶校验的条带化。 需要使用至少 3 个驱动器，像 RAID 0 一样跨多个驱动器条带化数据，但也有跨驱动器分布的奇偶校验。
    
    RAID 6：带双重奇偶校验的条带化。 RAID 6 类似于 RAID 5，但奇偶校验数据写入两个驱动器。
    
    RAID 10：结合了 RAID 0 和 RAID 1 的条带化和镜像。它通过在辅助驱动器上镜像所有数据来提供安全性，同时在每组驱动器上使用条带化来加速数据传输。RAID 0：也称为条带化，数据在阵列中的所有驱动器之间平均分配。


### Volumes 卷

`卷`是磁盘或磁带上的固定存储量。
术语卷通常用作存储本身的同义词，但单个磁盘可能包含多个卷或一个卷跨越多个磁盘


### File storage  文件存储


`文件存储`是一种将数据存储为文件并将其作为分层目录结构呈现给最终用户的解决方案。

主要优点是提供一个用户友好的解决方案来存储和检索文件。

要在文件存储中定位文件，需要文件的完整路径。

它经济实惠且结构简单，通常位于硬盘驱动器上，这意味着它们对用户和硬盘驱动器的显示完全相同。

    示例：Amazon EFS、Azure 文件、Google Cloud Filestore 等。


### Block storage 块存储


`块存储`将数据分成块（块）并将它们存储为单独的块。

每个数据块都有一个唯一的标识符，这允许存储系统将较小的数据块放在最方便的地方。

块存储还将数据与用户环境分离，允许数据分布在多个环境中。

这会创建多个数据路径，并允许用户快速检索数据。

当用户或应用程序向块存储系统请求数据时，底层存储系统重新组合数据块并将数据呈现给用户或应用程序

    示例：亚马逊 EBS。


### Object Storage 对象存储


`对象存储`，也称为基于对象的存储，将数据文件分解为称为对象的片段。

然后它将这些对象存储在一个存储库中，该存储库可以分布在多个联网系统中。

    示例：Amazon S3、Azure Blob Storage、Google Cloud Storage 等。

### NAS 网络附加存储


`NAS（网络附加存储）`是连接到网络的存储设备，允许授权网络用户从中央位置存储和检索数据。


NAS 设备是灵活的，这意味着当我们需要额外的存储空间时，我们可以添加到现有的空间中。


它速度更快、成本更低，并提供现场公共云的所有优势，让我们能够完全控制。


### 硬盘文件系统 HDFS (`The Hadoop Distributed File System`)

`Hadoop 分布式文件系统 (HDFS)` 是一种分布式文件系统，旨在在商用硬件上运行。

HDFS 具有高度容错性，旨在部署在低成本硬件上。

HDFS 提供对应用程序数据的高吞吐量访问，适用于具有大型数据集的应用程序。

它与现有的分布式文件系统有很多相似之处。

HDFS 旨在跨大型集群中的机器可靠地存储非常大的文件。

它将每个文件存储为一系列块，文件中除最后一个块外的所有块都具有相同的大小, 复制文件的块以实现容错。



<br>

