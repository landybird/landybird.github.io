---
title: gevent概述                                              
description: gevent的基本使用
categories:
- python
tags:
- python   
---

[>> gevent-tutorial](http://sdiehl.github.io/gevent-tutorial/)




### 基本内容

`gevent`是基于`libev`的并发库。它为各种`并发`和`网络相关任务`提供了一个干净的API


#### `Greenlets`


`gevent`中使用的主要模式是`Greenlet`，这是作为`C扩展模块`提供给Python的`轻量协程`。

`Greenlets`都在`主程序的OS进程内运行`，但是是`协同安排`的

    Only one greenlet is ever running at any given time.
    
    The primary pattern used in gevent is the Greenlet, a lightweight coroutine provided to Python as a C extension module.
    Greenlets all run inside of the OS process for the main program but are scheduled cooperatively
    
与由`multiprocessing`或`threading`提供的并行性构造不同， 
它们执行`spin processes`和`POSIX线程`（真正`由操作系统调度`，是真正并行的）

   
    This differs from any of the real parallelism constructs provided by multiprocessing or threading libraries 
    which do spin processes and POSIX threads which are scheduled by the operating system and are truly parallel.
    
   

#### 同步与异步执行

`并发`的`核心思想`是可以`将一个较大的任务分解为一组子任务`，这些子任务计划同时或异步运行，而不是一次或同步运行。

两个子任务之间的切换称为`上下文切换`


在GEVENT上下文切换是通过`yielding`得到


实例:


```python
import gevent

def foo():
    print('Running in foo')
    gevent.sleep(0)     # 调用
    print('Explicit context switch to foo again')

def bar():
    print('Explicit context to bar')
    gevent.sleep(0)   # 调用
    print('Implicit context switch back to bar')

gevent.joinall([
    gevent.spawn(foo),
    gevent.spawn(bar),
])

#  gevent.spawn(foo).join()
#  gevent.spawn(bar).join()



# Running in foo
# Explicit context to bar
# Explicit context switch to foo again
# Implicit context switch back to bar

```



当将`gevent` 用于`可协作调度`的`网络`和`IO绑定功能`时，gevent的真正力量就来了。

`Gevent`可以确保您的网络库在任何可能的情况下都`隐式地`产生其 `greenlet上下文（greenlet contexts ）`。


`select()` function is normally a blocking call that polls on various file descriptors.

`select()函数` 轮询各种文件描述符的阻塞调用


例子

```python

import time
import gevent
from gevent import select

start = time.time()
tic = lambda: 'at %1.1f seconds' % (time.time() - start)

def gr1():
    # Busy waits for a second, but we don't want to stick around...
    print('Started Polling: %s' % tic())
    select.select([], [], [], 2)
    print('Ended Polling: %s' % tic())

def gr2():
    # Busy waits for a second, but we don't want to stick around...
    print('Started Polling: %s' % tic())
    select.select([], [], [], 2)
    print('Ended Polling: %s' % tic())

def gr3():
    print("Hey lets do some stuff while the greenlets poll, %s" % tic())
    gevent.sleep(1)

gevent.joinall([
    gevent.spawn(gr1),
    gevent.spawn(gr2),
    gevent.spawn(gr3),
])

```
    
    Started Polling: at 0.0 seconds
    Started Polling: at 0.0 seconds
    Hey lets do some stuff while the greenlets poll, at 0.0 seconds
    Ended Polling: at 2.0 seconds
    Ended Polling: at 2.0 seconds


> `gevent.spawn`将函数包装在`Greenlet线程`中

例子：
```python

# 同步 vs 异步

import gevent
import random

def task(pid):
    """
    Some non-deterministic task
    """
    gevent.sleep(random.randint(0,2)*0.001)
    print('Task %s done' % pid)

def synchronous():
    for i in range(1,10):
        task(i)

def asynchronous():
    threads = [gevent.spawn(task, i) for i in xrange(10)]
    # gevent.spawn 将给定功能包装在Greenlet线程中
    # 初始化的greenlets列表存储在数组中threads，该数组传递给gevent.joinall函数
    gevent.joinall(threads)
    # 该函数阻止当前程序运行所有给定的greenlets。
    # 仅当所有greenlet终止时，执行才会向前执行

print('Synchronous:')
synchronous()

print('Asynchronous:')
asynchronous()


# Synchronous:
# Task 1 done
# Task 2 done
# Task 3 done
# Task 4 done
# Task 5 done
# Task 6 done
# Task 7 done
# Task 8 done
# Task 9 done
# Asynchronous:
# Task 1 done
# Task 5 done
# Task 6 done
# Task 2 done
# Task 4 done
# Task 7 done
# Task 8 done
# Task 9 done
# Task 0 done
# Task 3 done
```


网络请求的例子: （服务器异步获取数据）


```python
from gevent import monkey
monkey.patch_all()

import gevent
import requests
import json


def fetch(pid):
    response = requests.get('https://www.python.org/')
    result = response.text[:200]

    print('Process %s: %s' % (pid, result))
    return result

def synchronous():
    for i in range(1,10):
        fetch(i)

def asynchronous():
    threads = []
    for i in range(1,10):
        threads.append(gevent.spawn(fetch, i))
    gevent.joinall(threads)

print('Synchronous:')
synchronous()

print('Asynchronous:')
asynchronous()


```



#### `greenlets`是确定性的 `deterministic`


给定相同的`greenlet配置`和`相同的输入`，它们始终会`产生相同的输出`


```python


import time

def echo(i):
    time.sleep(0.001)
    return i

# Non Deterministic Process Pool

from multiprocessing.pool import Pool

p = Pool(10)
run1 = [a for a in p.imap_unordered(echo, xrange(10))]
run2 = [a for a in p.imap_unordered(echo, xrange(10))]
run3 = [a for a in p.imap_unordered(echo, xrange(10))]
run4 = [a for a in p.imap_unordered(echo, xrange(10))]

print(run1 == run2 == run3 == run4)

# False

# Deterministic Gevent Pool

from gevent.pool import Pool

p = Pool(10)
run1 = [a for a in p.imap_unordered(echo, xrange(10))]
run2 = [a for a in p.imap_unordered(echo, xrange(10))]
run3 = [a for a in p.imap_unordered(echo, xrange(10))]
run4 = [a for a in p.imap_unordered(echo, xrange(10))]

print(run1 == run2 == run3 == run4)


# True

```


> 并发相关的问题  `race condition`


即使`gevent`通常是`确定性`的，但当开始与`套接字`和`文件之类`的外部服务进行交互时，
`不确定性`的来源仍会渗入您的程序中

    两个并发线程/进程依赖于某个共享资源但还试图修改该值时，就会发生竞争状态。
    这导致资源的值随时间而变，取决于执行顺序

最好的方法是始终避免所有全局状态



#### Greenlets 的初始化包装 `Spawning Greenlets`



```python


import gevent
from gevent import Greenlet

def foo(message, n):
    """
    Each thread will be passed the message, and n arguments
    in its initialization.
    """
    gevent.sleep(n)
    print(message)

# Initialize a new Greenlet instance running the named function
# foo
thread1 = Greenlet.spawn(foo, "Hello", 1)

# Wrapper for creating and running a new Greenlet from the named
# function foo, with the passed arguments
thread2 = gevent.spawn(foo, "I live!", 2)

# Lambda expressions
thread3 = gevent.spawn(lambda x: (x+1), 2)

threads = [thread1, thread2, thread3]

# Block until all threads complete.
gevent.joinall(threads)
```


> 类的方式初始化 `Greenlet` 的`_run`方法 (类似thread)

```python

import gevent
from gevent import Greenlet

class MyGreenlet(Greenlet):

    def __init__(self, message, n):
        Greenlet.__init__(self)
        self.message = message
        self.n = n

    def _run(self):
        print(self.message)
        gevent.sleep(self.n)

g = MyGreenlet("Hi there!", 3)
g.start()
g.join()

```



#### Greenlet State 状态

    
    started -- Boolean, indicates whether the Greenlet has been started
    
    ready() -- Boolean, indicates whether the Greenlet has halted
    
    successful() -- Boolean, indicates whether the Greenlet has halted and not thrown an exception
    
    value -- arbitrary, the value returned by the Greenlet
    
    exception -- exception, uncaught exception instance thrown inside the greenlet



```python

import gevent

def win():
    return 'You win!'

def fail():
    raise Exception('You fail at failing.')

winner = gevent.spawn(win)
loser = gevent.spawn(fail)

print(winner.started) # True
print(loser.started)  # True

# Exceptions raised in the Greenlet, stay inside the Greenlet.
try:
    gevent.joinall([winner, loser])
except Exception as e:
    print('This will never be reached')

print(winner.value) # 'You win!'
print(loser.value)  # None

print(winner.ready()) # True
print(loser.ready())  # True

print(winner.successful()) # True
print(loser.successful())  # False

# The exception raised in fail, will not propagate outside the
# greenlet. A stack trace will be printed to stdout but it
# will not unwind the stack of the parent.

print(loser.exception)

# It is possible though to raise the exception again outside
# raise loser.exception
# or with
# loser.get()

```


#### 程序关闭 


主程序上侦听`SIGQUIT`事件，并`gevent.shutdown`在退出前调用

```python
import gevent
import signal

def run_forever():
    gevent.sleep(1000)

if __name__ == '__main__':
    gevent.signal(signal.SIGQUIT, gevent.kill)
    thread = gevent.spawn(run_forever)
    thread.join()
```

####  超时处理


```python
import gevent
from gevent import Timeout

seconds = 10

timeout = Timeout(seconds)
timeout.start()

def wait():
    gevent.sleep(10)

try:
    gevent.spawn(wait).join()
except Timeout:
    print('Could not complete')
    
    
# 上下文处理
import gevent
from gevent import Timeout

time_to_wait = 5 # seconds

class TooLong(Exception):
    pass

with Timeout(time_to_wait, TooLong):
    gevent.sleep(10)


# (3)

# --
import gevent
from gevent import Timeout

def wait():
    gevent.sleep(2)

timer = Timeout(1).start()
thread1 = gevent.spawn(wait)

try:
    thread1.join(timeout=timer)
except Timeout:
    print('Thread 1 timed out')

# --

timer = Timeout.start_new(1)
thread2 = gevent.spawn(wait)

try:
    thread2.get(timeout=timer)
except Timeout:
    print('Thread 2 timed out')

# --

try:
    gevent.with_timeout(1, wait)
except Timeout:
    print('Thread 3 timed out')

```



#### ` Monkey patching`


Python的运行时允许在运行时`修改大多数对象，包括模块，类甚至函数`

在极端情况下，如果一个库需要`更改Python本身的基本行为`，则可以使用`猴子补丁`


`gevent.monkey.patch_all()`


### 数据结构


#### Events

事件`Events`是Greenlets之间`异步通信的一种形式`

```python

import gevent
from gevent.event import Event

'''
Illustrates the use of events
'''


evt = Event()

def setter():
    '''After 3 seconds, wake all threads waiting on the value of evt'''
    print('A: Hey wait for me, I have to do something')
    gevent.sleep(3)
    print("Ok, I'm done")
    evt.set()


def waiter():
    '''After 3 seconds the get call will unblock'''
    print("I'll wait for you")
    evt.wait()  # blocking
    print("It's about time")

def main():
    gevent.joinall([
        gevent.spawn(setter),
        gevent.spawn(waiter),
        gevent.spawn(waiter),
        gevent.spawn(waiter),
        gevent.spawn(waiter),
        gevent.spawn(waiter)
    ])

if __name__ == '__main__': main()

```


