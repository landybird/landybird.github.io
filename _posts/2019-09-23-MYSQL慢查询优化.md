---
title: MYSQL慢查询优化
description: MYSQL慢查询优化
categories:
- mysql
tags:
- mysql
---


SQL 应用程序中一个常见的问题就是`性能退化`


处理慢查询的三个技巧: 

`调优查询本身`，  `调优表(包括增加索引)`，  `调优服务器`



#### 通过`EXPLAIN`的信息调优查询


`explain 命令` 其主要功能是用来分析 `select 语句的运行效果`

    例如  select语句使用的索引情况、排序的情况等等。
    
`explain 的extended 扩展` 能够在原本explain的基础上额外的提供一些查询优化的信息，这些信息可以通过MySQL的`show warnings`命令得到


    explain extended select * from account\G;
    
    show warnings\G;  # 查看优化信息建议
    
    
    


- `Type` 展示了连接(join)的执行方式

- `Rows` 展示了在查询执行过程中检查的行数的估计(如果查询要扫描整个表, rows的数值于表行数相同) 

`多表连接`需要检查的行数是每个表 检查行数的`笛卡尔积`
    
    一个表20行， 另一个表是30行， 连接一共执行600次检查
    

``
    
    id	select_type 	TABLE	   TYPE	 possible_keys	KEY	   key_len	 ref	ROWS	filtered	Extra
    
    1	SIMPLE	       gg_customer	ALL	     \N	         \N	    \N	      \N	 78  	100.00	      \N
    


#### 表调优和`索引`


在 `WHERE`，  `JOIN`，  `GROUP BY`， `ORDER BY`语句中`加入索引`可以`加速查询`

> 索引的设计原则

- 创建索引的列并不一定是select操作中要查询的列，`最适合做索引的列`是出现在`where子句`中经常用作`筛选条件`或连表子句中作为`表连接条件的列`。

- `具有唯一性的列，索引效果好`；重复值较多的列，索引效果差。

- 如果为字符串类型创建索引，最好指定一个前缀长度，创建短索引。短索引可以减少磁盘I/O而且在做比较时性能也更好，更重要的是MySQL底层的高速索引缓存能够缓存更多的键值。

- 创建一个包含`N列的复合索引（多列索引）`时，相当于是创建了N个索引，此时应该利用最左前缀进行匹配。

- `不要过度使用索引`。索引并不是越多越好，索引需要占用额外的存储空间而且会影响写操作的性能（插入、删除、更新数据时索引也需要更新）。MySQL在生成执行计划时，要考虑各个索引的使用，这个也是需要耗费时间的。

- 要注意可能使`索引失效`的场景，例如：模糊查询使用了前置通配符、使用负向条件进行查询等


- 索引也有减慢查询的时候， 这时候应该`忽略 IGNORE INDEX` 或者 `强制指定索引 FORCE INDEX`




#### 修改数据的调优 (`UPDATE`, `DELETE`)


在优化某个动作的时候， 要注意整个应用程序的性能


查看当前会话的状态


    SHOW STATUS LIKE 'HANDLER_%'
    
    Handler_commit	9
    Handler_delete	0
    Handler_discover	0
    Handler_external_lock	18
    Handler_mrr_init	0
    Handler_prepare	0
    Handler_read_first	6
    Handler_read_key	6
    Handler_read_last	0
    Handler_read_next	0
    Handler_read_prev	0
    Handler_read_rnd	0
    Handler_read_rnd_next	3809     表示从datafile读取下一个值的频繁程度， 过高代表全表扫描
    Handler_rollback	0
    Handler_savepoint	0
    Handler_savepoint_rollback	0
    Handler_update	0
    Handler_write	707

    
    FLUSH STATUS 可以重置


`Handler_read_rnd_next` 表示从datafile读取下一个值的频繁程度， 过高代表全表扫描


`Handler_read_key`  读取索引的请求数目， 过低表明没有使用索引


`Handler_commit`   事务提交次数


`Handler_read_first`  读取索引中第一项的次数, 如果是1 ， 表示我们请求服务器读取索引的第一条记录，即全表扫描



表中的索引会影响 `INSERT ` 操作的效率

插入操作会阻塞行甚至是整张表


#### 表数据分区 partiation

MySQL支持做`数据分区`，通过分区`可以存储更多的数据`、`优化查询`，`获得更大的吞吐量`并`快速删除过期的数据`


- `RANGE分区`：基于`连续区间范围`，把数据分配到不同的分区。

[partitioning-overview](https://dev.mysql.com/doc/refman/5.7/en/partitioning-overview.html)
```sql
CREATE TABLE tb_emp (
    eno INT NOT NULL,
    ename VARCHAR(20) NOT NULL,
    job VARCHAR(10) NOT NULL,
    hiredate DATE NOT NULL,
    dno INT NOT NULL
)
PARTITION BY RANGE( YEAR(hiredate) ) (
    PARTITION p0 VALUES LESS THAN (1960),
    PARTITION p1 VALUES LESS THAN (1970),
    PARTITION p2 VALUES LESS THAN (1980),
    PARTITION p3 VALUES LESS THAN (1990),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);
```

- `LIST分区`：基于`枚举值的范围`，把数据分配到不同的分区。

- `HASH分区 / KEY分区`：`基于分区个数`，把数据分配到不同的分区。

```sql
CREATE TABLE tb_emp (
    eno INT NOT NULL,
    ename VARCHAR(20) NOT NULL,
    job VARCHAR(10) NOT NULL,
    hiredate DATE NOT NULL,
    dno INT NOT NULL
)
PARTITION BY HASH(dno)
PARTITIONS 4;
```
