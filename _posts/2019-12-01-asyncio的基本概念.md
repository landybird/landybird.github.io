---
title: asyncio的基本概念
description: asyncio的基本概念
categories:
- python
tags:
- asyncio
---

[参考--使用Python进行并发编程](https://www.dongwm.com/post/83/)

> 核心关键字 `Eventloop` + `Coroutine` + `Future` + `Task`



#### Eventloop 

 asyncio 应用的`核心`，是中央总控。Eventloop 实例提供了`注册、取消和执行任务和回调的方法`。
 
 把一些异步函数 (就是任务，`Task`) 注册到这个事件循环上，事件循环会循环执行这些函数 (但同时只能执行一个)，当执行到某个函数时，如果它正在等待 I/O 返回，事件循环会暂停它的执行去执行其他的函数；当某个函数完成 I/O 后会恢复，下次循环到它的时候继续执行。
 
 因此，这些`异步函数可以协同 (Cooperative) 运行`：这就是事件循环的目标
 
 
 asyncio 根据你的操作系统信息会帮你选择`默认的事件循环类`
 
 在`*nix` 下使用的类继承于 `BaseEventLoop`
 
 
`eventloop的基本实现`


```python

#  call_exception_handler 和 get_debug 是必须存在 

from collections import deque


def done_callback(fut):
    fut._loop.stop()


class Loop:
    def __init__(self):
        self._ready = deque()
        self._stopping = False

    def create_task(self, coro):
        Task = asyncio.tasks.Task
        task = Task(coro, loop=self)
        return task

    def run_until_complete(self, fut):
        tasks = asyncio.tasks
        # 获取任务
        fut = tasks.ensure_future(
                    fut, loop=self)
        # 增加任务到self._ready
        fut.add_done_callback(done_callback)
        # 跑全部任务
        self.run_forever()
        # 从self._ready中移除
        fut.remove_done_callback(done_callback)

    def run_forever(self):
        try:
            while 1:
                self._run_once()
                if self._stopping:
                    break
        finally:
            self._stopping = False

    def call_soon(self, cb, *args):
        self._ready.append((cb, args))

    def _run_once(self):
        ntodo = len(self._ready)
        for i in range(ntodo):
            t, a = self._ready.popleft()
            t(*a)

    def stop(self):
        self._stopping = True

    def close(self):
        self._ready.clear()

    def call_exception_handler(self, c):
        pass

    def get_debug(self):
        return False



async def foo():
    print('Hello Foo')


async def bar():
    print('Hello Bar')

loop = Loop()
tasks = [loop.create_task(foo()),
         loop.create_task(bar())]
loop.run_until_complete(
        asyncio.wait(tasks))
loop.close()
```
 

#### Coroutine


协程 (Coroutine) `本质上是一个函数，特点是在代码块中`可以将执行权交给其他协程`：


```python

# coding: utf-8

import asyncio


async def a():
    print("Suspending a")
    await asyncio.sleep(0)
    # 协程 a 被挂起，  sleep 0 并不会真的 sleep（因为时间为 0），但是却可以把控制权交出去
    print("Resuming a")


async def b():
    print("fn b")


async def main():
    await asyncio.gather(a(), b())
    # asyncio.gather 用来并发运行任务


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    loop.close()

    # asyncio.run(main())   Python 3.7+ 新加的接口

```


#### Future

代表了一个`「未来」对象`，异步操作结束后会`把最终结果设置到这个 Future 对象上`

Future 是`对协程的封装`，不过日常开发基本是不需要直接用这个底层 Future 类的


> future 對象的方法 属性

        cancel
        cancelled
        done
        exception
        get_loop
        remove_done_callback
        result
        set_exception
        set_result
        Process
        finished
        
    
可以对这个 Future 实例添加`完成后的回调 (add_done_callback)`、`取消任务 (cancel)`、  设置最终结果 `(set_result)`、`设置异常 (如果有的话，set_exception)` 等



future 对象 在 `await` 之后状态成了 finished


    因为用loop.run_in_executor创建的 Future 注册了一个回调（通过asyncio.futures.wrap_future，
    加了一个_call_set_state回调
    

```python
# 一个对象可以被 await 的条件

def __await_(self):
    if not self.done():
        self._asyncio_future_blocking = True
        yield self
    if not self.done():
        raise RuntimeError("await wasn't used with future")
    return self.result()

```


#### Task 



`Eventloop` 除了支持`协程`，还支持注册 `Future` 和 `Task` 类型的对象


- Future 是协程的封装 


    Future 对象提供了很多任务方法 (如完成后的回调、取消、设置任务结果等等)，
    但是开发者并不需要直接操作 Future 这种底层对象


- Task `Future 的子类`
 
 
     协同的调度协程以实现并发
     
     
Task 类用来管理协同程序运行的状态


`Task类的基本实现`

```python
import asyncio


class Task(asyncio.futures.Future):
    def __init__(self, gen, *,loop):
        super().__init__(loop=loop)
        self._gen = gen
        self._loop.call_soon(self._step)

    def _step(self, val=None, exc=None):
        # 如果_step 方法没有让协程执行完成，就会添加回调，_wakeup 又会继续执行_step... 直到协程程序完成，并 set_result。
        # 写个使用它的例子：
        try:
            if exc:
                f = self._gen.throw(exc)
            else:
                f = self._gen.send(val)
        except StopIteration as e:
            self.set_result(e.value)
        except Exception as e:
            self.set_exception(e)
        else:
            f.add_done_callback(
                 self._wakeup)

    def _wakeup(self, fut):
        # _wakeup 又会继续执行_step... 直到协程程序完成，并 set_result
        try:
            res = fut.result()
        except Exception as e:
            self._step(None, e)
        else:
            self._step(res, None)
            



async def foo():
    await asyncio.sleep(2)
    print('Hello Foo')


async def bar():
    await asyncio.sleep(1)
    print('Hello Bar')


loop = asyncio.get_event_loop()
tasks = [Task(foo(), loop=loop),
         loop.create_task(bar())]
loop.run_until_complete(
        asyncio.wait(tasks))
loop.close()
```





#### `asyncio 并发` 正确的使用方式


`create_task `是 AbstractEventLoop 的抽象方法，不同的 loop 可以实现不同的创建 Task 方法，这里用的是 BaseEventLoop 的实现。

`ensure_future` 是 asyncio 封装好的创建 Task 的函数，它还支持一些参数，甚至指定 loop。
一般应该使用它 


```python

import asyncio
import time

async def a():
    print('Suspending a')
    await asyncio.sleep(3)
    print('Resuming a')


async def b():
    print('Suspending b')
    await asyncio.sleep(1)
    print('Resuming b')

# 错误的用法1
async def e1():
    await a()
    await b()

# 错误的用法2
# 直接 await task 不会对并发有帮助
async def e2():
    await asyncio.create_task(a())
    await asyncio.create_task(b())



async def c1():
    await asyncio.gather(a(), b())


async def c2():
    await asyncio.wait((a(), b()))


async def c3():
    # asyncio.create_task 相当于把协程封装成 Task
    task1 = asyncio.create_task(a())
    task2 = asyncio.create_task(b())
    await task1
    await task2


async def c4():
    task1 = asyncio.create_task(a())
    await b()
    await task1

async def c5():
    task = asyncio.ensure_future(b())
    await a()
    # 挂起 a(), 
    await task


async def c6():
    loop = asyncio.get_event_loop()
    task = loop.create_task(b())
    await a()
    await task


#  time.perf_counter  是现在推荐的计算耗时的用法

def show_perf(func):
    print('*' * 20)
    start = time.perf_counter()
    asyncio.run(func())
    print(f'{func.__name__} Cost: {time.perf_counter() - start}')


if __name__ == '__main__':
    show_perf(c4)
```
