---
title: 后端存储小结                                               
description: 后端存储小结
categories:
- 架构
tags:
- 架构   
---

### 存储系统

常见的业务系统很多都是 `MIS系统` -- `管理信息系统`


    -->> 信息数据的管理 
    

`存储`是系统中`最核心`的组成部分， 直接影响系统的速度与稳定性 




### 设计一个电商系统 (`需求分析`)


> 需求分析  --  系统的用户(`给哪些人用`)， 用户用来干什么(`不同的人用来解决什么问题`)


> 使用不同的图 来明确需求



#### `UML (统一建模语言)`中的 `用例图 Use Case`

    1 系统给谁用
    
    2 不同的用户用来解决什么问题
    

 ![](https://landybird.github.io/landybird.github.io/assets/images/usecase.png)




#### 流程图 


 ![](https://landybird.github.io/landybird.github.io/assets/images/flowchart.png)




####  时序图  (细化流程)


 ![](https://landybird.github.io/landybird.github.io/assets/images/sequence.jpg)




####  `UML (统一建模语言)`中的 `包图 package diagram`



 ![](https://landybird.github.io/landybird.github.io/assets/images/package.jpg)


    
    商品：维护和展示商品信息和价格。
    
    订单：维护订单信息和订单状态，计算订单金额。
    
    购物车：维护用户购物车中的商品。
    
    支付：负责与系统内外部的支付渠道对接，实现支付功能。
    
    库存：维护商品的库存数量和库存信息。
    
    促销：制定促销规则，计算促销优惠。（最复杂 -- 各种活动， 规则计算） 
    
    用户：维护系统的用户信息，注意用户模块它是一个业务模块，一般不负责用户登录和认证，这是两个完全不同的功能。
    
    账户：负责维护用户的账户余额。
    
    搜索推荐：负责商城中，搜索商品和各种列表页和促销页的组织和展示，简单的说就是决定让用户优先看到哪些商品。
   
    报表：实现统计和分析功能，生成报表，给老板来做经营分析和决策使用。
    




###  小规模的订单存储系统


`幂等服务的实现`



#### 订单表的设计


    1  订单主表            保存订单的基本信息
    
    2  订单商品表          保存订单中的商品信息
    
    3  订单支付表          保存 支付， 退款信息 
    
    4  订单优惠表          保存订单使用的优惠券的信息
    
    
     
#### 创建订单 `INSERT`

> `防重` --- `幂等操作` -- `一个幂等的创建订单服务`  

使用相同的参数， 多次调用 和 一次调用， 对系统产生的影响是一样的 
    
    任意多次操作的影响 均与 一次执行的影响相同 
    

解决方法:   利用数据库的主键唯一约束

    
        1  先向后端请求获取一个 订单号, 返回给前端 (作为订单数据段饿唯一主键)
        
        2  创建订单的时候， 把订单号传递给后端
        
        3  重复提交会产生 异常
        
       
 ![](https://landybird.github.io/landybird.github.io/assets/images/order.jpg)

    
####  订单系统的更新服务 `UPDATE`


也需要`幂等性`


`更新操作` --- `天然幂等`， 但是需要我们注意 `ABA 问题`


`ABA 问题: `

     正常情况:  status -> status1 -> status2 
     
     
     异常情况:  1 status -> status1 （响应超时）

                2 status -> status2  
                
                3 status -> status1 (重试)
                
                最后 status1


![](https://landybird.github.io/landybird.github.io/assets/images/order1.jpg)



> 解决`ABA`问题    `增加版本号(表明请求的先后顺序)`




给订单主表增加一列 `version` , 用来`区分更新请求的时间先后` 


    每次查询订单数据， 把版本号一起返回。
    
    在更新数据的时候， 把版本号作为请求参数， 返回给订单系统
    
    如果版本号一致， 也需要更新操作的时候， 版本号+1
    

`比较版本号`， `更新数据`, `版本号+1` 的操作必须在`同一个事务`里面执行

```sql
update orders set tracking_number = 666, version = version + 1 
where version = 8
```



![](https://landybird.github.io/landybird.github.io/assets/images/order3.JPG)
#### `大数据量`的商品详情页面


> 商品系统需要保存的数据

 ![](https://landybird.github.io/landybird.github.io/assets/images/order4.JPG)




`注意 保存商品的历史版本`


> 1  `商品的基本信息``


`数据库` + `前置缓存`  --- `cached aside策略`



    查询 :          
         1   缓存中有， 直接返回
         2   缓存中没有， 数据库查询， 写入缓存

        
    更新： 
        更新数据库的同时， 把之前的缓存删掉


> 2 使用` Mongo` 保存`商品参数`


`BSON` 更紧凑的 `JSON`



> 3 使用`对象存储 object storage` 保存 `图片, 视频`



数据库 中存储 视频， 图片`ID` 或者 `url`

实际的媒体资源以`文件的形式` 单独存储


    七牛云
    
    AWS 的 S3



`对象存储`可以理解为一个无限容量的 `kv存储`， `存储单位`是 `对象` 

    
    每个对象都有一个key ， 通过这个key可以进行 对应文件的操作
    
    大部分的 云存储服务 都自带CDN （Content Delivery Network） 加速


> 4 将 `商品介绍` -- `静态化`

页面直接生成好， 保存一个静态的`HTML`


    节省服务器资源
    
  
  
![](https://landybird.github.io/landybird.github.io/assets/images/order5.jpg)
 
#### 购物车系统 


需要考虑的问题:
    
        
        1  如果未登录 -- 临时暂存购物车商品
        
        2  用户登录 -- 把暂存的商品合并到用户的购物车中 ， 并且清除临时暂存的购物车
        
        3  用户登录后 -- 购物车需要在 PC ， app, 小程序等终端保持一致
        
        
  

> 两类购物车 :  `暂存购物车`  + `用户购物车`


- 暂存购物车 -- `客户端`


存储介质 


    Session   不合适    
                    1 保留时间短
                    2 实际还是在服务端
               
                    
    Cookie   
     
              优点
                    实现简单                     
                    服务端可以获取
                    
              缺点 
                    上限 4KB
                    每次请求都会带着， 浪费带宽
                    
    
    LocalStorage    
                
                优点
                    容量大
                    节省带宽
                
                缺点
                    实现复杂
                    只能客户端访问


暂存临时购物车的格式

```json
{
  "cart":[
   {
    "SKUID": 8888,
    "timestamp": 15734335,
    "count": 1,
    "selected": true
  },
   {
    "SKUID": 8889,
    "timestamp": 15734335,
    "count": 1,
    "selected": false
  }
  ]
}
```
                
                
   
- 用户购物车


|列名|数据类型|主键|非空|说明|
|---|---|---|---|---|
|id|BIGINT|是|是|---|
|user_id|BIGINT|---|是|---|
|sku_id|BIGINT|---|是|商品ID|
|count|INT|---|是|商品数量|
|timestamp|DATE|---|是|---|
|selected|TINYINT(1)|---|---|---|


     
`Mysql` 与 `Redis`的比较:

    
    1 性能                  redis > mysql
    
    2 数据可靠性            mysql > redis（丢数据）
    
    3 查询丰富, 事务机制    mysql > redis
    
    



    









### 扩容， 单机到分布式

### 海量数据， 与实时性




 



