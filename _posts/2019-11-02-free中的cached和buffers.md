---
title: free中的cached和buffers
description: free中的cached和buffers
categories:
- linux
tags:
- linux
---


####  实例

命令:

```bash

free -g

             total       used       free     shared    buffers     cached
Mem:            15         11          4          0          0          1
-/+ buffers/cache:          9          5
Swap:            0          0          0



# Mem:

#   15     物理内存总量  
#   11     总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用
#    4     未被分配的内存
#    0     共享内存，一般系统不会用到，这里也不讨论
#    1     系统分配但未被使用的buffers 数量


#  -/+ buffers/cache:       

#    9     实际使用的buffers 与cache 总量，也是实际使用的内存总量
#    5     未被 使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存


```

#### 概念


`cached`是cpu与内存间的，

`buffer`是内存与磁盘间的，

都是为了解决速度不对等的问题


`缓存（cached）`是把读取过的数据保存起来，重新读取时若命中（找到需要的数据）就不要去读硬盘了，若没有命中就读硬盘。

    其中的数据会根据读取频率进行组织，把最频繁读取的内容放在最容易找到的位置，把不再读的内容不断往后排，直至从中删除

`缓冲（buffers）`是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。

    linux有一个守护进程定期 清空缓冲内容（即写入磁盘），也可以通过sync命令手动清空缓冲。
    
    举个例子吧：我这里有一个ext2的U盘，我往里面cp一个3M的MP3，但U盘的灯 没有跳动，过了一会儿（或者手动输入sync）U盘的灯就跳动起来了。
    卸载设备时会清空缓冲，所以有些时候卸载一个设备时要等上几秒钟

 
`buffer`是由各种进程分配的，被用在如输入队列等方面。

    一个简单的例子如某个进程要求有多个字段读入，在所有字段被读入完整之前，进程把先前读入的字段放在buffer中保存

`cache`经常被用在磁盘的I/O请求上，如果有多个进程都要访问某个文件，于是该文件便被做成cache以方便下次被访问，这样可提高系统性能

