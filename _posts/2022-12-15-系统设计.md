---
title: System Design 系统设计
description: 了解如何大规模设计系统并准备系统设计面试
categories:
- System Design
  tags:
- System Design
---

<br>


> 原文引用 -- [System Design](https://kps.hashnode.dev/system-design-the-complete-course#heading-domain-name-system-dns)

<br>


# 开始

---

## 什么是系统设计？

> 系统设计是为满足特定要求的系统，定义体系结构、接口和数据的过程。

系统设计通过连贯高效的系统满足业务或组织的需求,
它需要一种系统的方法来构建, 一个好的系统设计需要我们考虑一切，
从基础设施一直到数据及其存储方式。


## 为什么系统设计如此重要？

系统设计帮助我们定义满足业务需求的解决方案。
这是我们在构建系统时可以做出的最早决定之一。

通常必须从高层次思考，因为这些决定以后很难纠正。

随着系统的发展，它还可以更轻松地推理和管理架构更改。

---

<br>

---


# Chapter I 基础概念


<br>

---


## IP

`IP 地址`是在 Internet 或本地网络上`标识设备的唯一地址`。
IP 代表“互联网协议”，它是管理通过互联网或本地网络发送的数据格式的一组规则。

本质上，`IP 地址` 是允许信息在网络上的设备之间发送的标识符。
它们包含位置信息并使设备可访问以进行通信。 互联网需要一种方法来区分不同的计算机、路由器和网站。
IP 地址提供了一种这样做的方式，并构成了互联网工作方式的重要组成部分。


### Versions  版本


#### `IPv4`

最初的互联网协议是 IPv4，它使用 32 位数字点十进制表示法，只允许大约 40 亿个 IP 地址。

最初，它绰绰有余，但随着互联网普及率的增长，我们需要更好的东西。

    示例：102.22.192.181

#### `IPv6`

IPv6 是 1998 年引入的新协议。
部署始于 2000 年代中期，并且由于互联网用户呈指数级增长，它仍在进行中。

这个新协议使用 128 位字母数字十六进制表示法。 这意味着 IPv6 可以提供大约 ~340e+36  个 IP 地址。

这足以满足未来几年不断增长的需求。

    示例：2001:0db8:85a3:0000:0000:8a2e:0370:7334


###  Types 类型


####  Public

`公共 IP 地址`是一个主地址与您的整个网络相关联的地址。
在这种类型的 IP 地址中，每个连接的设备都具有相同的 IP 地址。

    示例：ISP 提供给您的路由器的 IP 地址

####  Private

`私有 IP 地址`是分配给连接到互联网网络的每台设备的唯一 IP 编号，其中包括您家中使用的计算机、平板电脑和智能手机等设备。

    示例：您的家庭路由器为您的设备生成的 IP 地址。

#### Static

`静态 IP 地址`不会改变，是手动创建的，而不是已分配的。

这些地址通常更昂贵但更可靠。

    示例：它们通常用于重要的事情，例如可靠的地理位置服务、远程访问、服务器托管等。

#### Dynamic

`动态 IP 地址`会不时更改，并不总是相同。 它已由动态主机配置协议 (DHCP) 服务器分配。
动态 IP 地址是最常见的互联网协议地址类型。
它们的部署成本更低，并允许我们根据需要在网络中重复使用 IP 地址。

    示例：它们更常用于消费设备和个人用途。



<br>

---


<br>

---



## OSI模型

`OSI 模型`是一种逻辑和概念模型，它定义了系统所使用的网络通信，这些系统对与其他系统的互连和通信开放。

开放系统互连（OSI 模型）还定义了一个逻辑网络，并通过使用各种协议层有效地描述了`计算机数据包传输`。

`OSI 模型可以看作是计算机网络的通用语言`。

它基于将通信系统分成`七个抽象层`的概念，每个抽象层堆叠在最后一个之上。


### 为什么 `OSI 模型`很重要？

`开放系统互连 (OSI) 模型`定义了网络讨论和文档中使用的通用术语。

这使我们能够将`非常复杂的通信过程`分开并评估其组成部分。

虽然这个模型没有直接在当今最常见的 `TCP/IP 网络`中实现，但它仍然可以帮助我们做更多的事情，比如:

    简化故障排除并帮助识别整个堆栈中的威胁。 
    
    鼓励硬件制造商创建可以通过网络相互通信的网络产品。
    
    对于培养安全第一的心态至关重要。
    
    将复杂的功能分解为更简单的组件。


###  `OSI 模型`的七个抽象层 `Layers` (从上到下)


####  应用 Application

`这是唯一直接与用户数据交互的层`

Web 浏览器和电子邮件客户端等软件应用程序依赖`应用程序层`来启动通信。

但应该明确的是，客户端软件应用程序不是应用程序层的一部分，`应用程序层`负责软件所依赖的协议和数据操作，以向用户提供有意义的数据。

应用层协议包括 `HTTP` 和 `SMTP`。


#### 表示 Presentation

`表示层也称为翻译层`。

来自应用层的数据在这里被提取并按照所需的格式进行操作以通过网络传输。

表示层的功能是`翻译、加密/解密和压缩`


#### 会话 Session

`会话层` 是负责`打开`和`关闭`两个设备之间通信的层。

`通信打开和关闭之间的时间称为会话`。

`会话层`确保会话保持打开足够长的时间以传输所有正在交换的数据，然后及时关闭会话以避免资源浪费。

`会话层`还将数据传输与检查点同步


#### 传输 Transport

`传输层`（也称为第 4 层）负责两个设备之间的端到端通信。

这包括从`会话层`获取数据并将其`分解`为称为段的块，然后再将其发送到网络层（第 3 层）。

它还负责将接收设备上的段`重组`为会话层可以使用的数据。


#### 网络 Network

`网络层`负责促进两个不同网络之间的数据传输。

网络层在发送方设备上将来自传输层的数据段分解为更小的单元（称为`数据包`），并在接收设备上重新组装这些数据包。

网络层还为数据找到到达目的地的最佳物理路径，这称为`路由`。

如果通信的两个设备在`同一网络上`，则不需要网络层。


#### 数据链路 Data Link

`数据链路层`与网络层非常相似，除了数据链路层有助于同一网络上两个设备之间的数据传输。

数据链路层从网络层获取数据包并将它们分成更小的部分，称为`帧`。


#### 物理层 Physical

`物理层`包括数据传输中涉及的物理设备，例如电缆和交换机。

这也是将数据转换为`比特流`的层，比特流是由 1 和 0 组成的字符串。

两个设备的`物理层`还必须就信号约定达成一致，以便可以区分两个设备上的 1 和 0。



<br>

---


<br>

---



## TCP and UDP


### TCP

传输控制协议 `Transmission Control Protocol` (TCP) 是面向连接的，这意味着一旦建立了连接，就可以双向传输数据。

TCP 具有内置系统来检查错误并保证数据按发送顺序传送，使其成为传输静止图像、数据文件和网页等信息的完美协议。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/tcp-and-udp/tcp.png)

但是，虽然 TCP 本能地可靠，但其`反馈机制`也导致更大的开销，转化为更多地使用网络上的可用带宽。

### UDP

`User Datagram Protocol` 用户数据报协议 (UDP) 是一种更简单的`无连接`互联网协议，其中不需要错误检查和恢复服务。

使用 UDP，没有用于打开连接、维护连接或终止连接的开销。

数据不断发送给接收者，无论他们是否收到。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/tcp-and-udp/udp.png)


对于广播或多播网络传输之类的实时通信，`UDP` 在很大程度上是首选。

当我们需要`最低延迟`并且延迟数据 > 数据丢失 ，我们应该使用 UDP > TCP


### TCP vs UDP


TCP 是一种面向连接的协议，而 UDP 是一种无连接协议。

TCP 和 UDP 之间的一个主要区别是速度，因为 TCP 比 UDP 相对慢。

    总的来说，UDP 是一种更快、更简单、更高效的协议; 但是，只有 TCP 才能重传丢失的数据包。

TCP 提供从用户到服务器的有序数据传输（反之亦然），而 UDP 不专用于端到端通信，也不检查接收方是否准备就绪。


|Feature|TCP|UDP|
|---|---|---|
|`Connection 连接`|需要建立连接|无连接协议|
|`Guaranteed delivery 保证交付`|可以保证数据交付|不能保证数据交付|
|`Re-transmission 重传`|可以重新传输丢失的数据包|可以重新传输丢失的数据包|
|`Speed 速度`|`Slower than UDP`|`Faster than TCP`|
|`Broadcasting 广播`|不支持广播|支持广播|
|`Use cases 用例`|`HTTPS, HTTP, SMTP, POP, FTP, etc`|`Video streaming, DNS, VoIP, etc`|



<br>

---



## 域名系统 (DNS)

IP 地址，它使每台机器都能与其他机器连接。

但正如我们所知，人类更喜欢名字而不是数字。

像 `google.com` 这样的名字比 `122.250.192.232` 这样的名字更容易记住

这将我们带到了`域名系统 (DNS)`，它是一种分层和分散的命名系统，用于将人类可读的域名转换为 IP 地址



### DNS 如何工作


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/domain-name-system/how-dns-works.png)


DNS 查找包括以下八个步骤:

    客户端在 Web 浏览器中键入 `example.com`，查询传输到 Internet 并由 DNS 解析器接收。
    
    解析器然后递归地查询 DNS 根名称服务器。
    
    根服务器使用顶级域 (TLD) 的地址响应解析器。 
    
    然后，解析器向 .com TLD 发出请求。
    
    TLD 服务器然后使用域名称服务器 example.com 的 IP 地址进行响应。 
    
    最后，递归解析器向域的名称服务器发送查询。 
    
    example.com 的 IP 地址随后从名称服务器返回给解析器。 
    
    然后，DNS 解析器使用最初请求的域的 IP 地址响应 Web 浏览器。

解析 IP 地址后，客户端应该能够从已解析的 IP 地址请求内容。
例如，解析后的IP可能会返回一个网页，在浏览器中呈现


### 构成 DNS 基础设施的四个关键服务器组  Server types


#### DNS 解析器  Resolver

`DNS 解析器`（也称为 DNS 递归解析器）是 DNS 查询的第一站。

递归解析器充当客户端和 DNS 名称服务器之间的中间人。

在从 Web 客户端接收到 DNS 查询后，递归解析器将使用缓存数据进行响应，或者向根名称服务器发送一个请求，然后向 TLD 名称服务器发送另一个请求，然后向权威名称服务器发送最后一个请求。
在从包含请求的 IP 地址的权威名称服务器收到响应后，递归解析器随后向客户端发送响应。


####  DNS 根服务器  Root Server

`根服务器` 接受包含域名的递归解析器查询，根名称服务器根据该域的扩展名（.com、.net、.org 等）通过将递归解析器定向到 TLD 名称服务器进行响应 .).

根名称服务器由名为互联网名称与数字地址分配机构 (ICANN) 的非营利组织监管。

每个递归解析器都知道 13 个 DNS 根名称服务器。

请注意，虽然有 13 个根名称服务器，但这并不意味着根名称服务器系统中只有 13 台机器。

有 13 种类型的根域名服务器，但每一种在世界各地都有多个副本，它们使用 Anycast 路由来提供快速响应。


####  TLD 名称服务器  TLD nameserver

`TLD 名称服务器`维护共享公共域扩展名的所有域名的信息，例如 .com、.net 或 URL 中最后一个点之后的任何名称。

TLD 名称服务器的管理由互联网号码分配机构 (IANA) 负责，它是 ICANN 的一个分支机构。

IANA 将 TLD 服务器分为两个主要组：

- 通用顶级域：这些是 `.com、.org、.net、.edu 和 .gov 等域`。

- 国家代码顶级域：这些包括特定于国家或州的任何域。示例包括 `.uk、.us、.ru 和 .jp`。


#### 权威DNS服务器 Authoritative DNS server

`权威域名服务器`通常是解析器获取 IP 地址的最后一步。

权威名称服务器包含特定于其服务的域名的信息（例如 google.com），并且它可以提供递归解析器，
其中包含在 DNS A 记录中找到的该服务器的 IP 地址，或者如果该域具有 CNAME 记录（别名） 它将为递归解析器提供别名域，
此时递归解析器将必须执行全新的 DNS 查找以从权威名称服务器获取记录（通常是包含 IP 地址的 A 记录）。

如果找不到域，则返回 `NXDOMAIN` 消息


### DNS 系统中存在三种类型的查询  Query Types


#### 递归 Recursive

在递归查询中，DNS 客户端要求 DNS 服务器（通常是 DNS 递归解析器）将使用请求的资源记录或错误消息响应客户端（如果解析器找不到记录）


#### 迭代 Iterative

在迭代查询中，DNS 客户端提供主机名，DNS 解析器返回它所能提供的最佳答案。

如果 DNS 解析器在其缓存中有相关的 DNS 记录，它会返回它们。
如果不是，它会将 DNS 客户端指向根服务器或距离所需 DNS 区域最近的另一个权威名称服务器。
然后 DNS 客户端必须直接对它所引用的 DNS 服务器重复查询。

#### 非递归查询 Non-recursive

非递归查询是 DNS 解析器已经知道答案的查询。

它要么立即返回 DNS 记录，因为它已经将它存储在本地缓存中，要么查询对记录具有权威性的 DNS 名称服务器，
这意味着它肯定拥有该主机名的正确 IP。

在这两种情况下，都不需要额外的查询轮次（如递归或迭代查询）。
相反，响应会立即返回给客户端


### DNS records

DNS 记录（又名区域文件）是权威 DNS 服务器中的指令，
提供有关域的信息，包括与该域相关联的 IP 地址以及如何处理对该域的请求

这些记录由一系列以所谓的 DNS 语法编写的文本文件组成。
DNS 语法只是用作命令的一串字符，告诉 DNS 服务器要做什么

所有 DNS 记录也有一个“TTL”，代表生存时间，表示 DNS 服务器刷新该记录的频率


一些最常用的记录类型：

    A（地址记录）：这是保存域 IP 地址的记录。 
    
    AAAA（IP 版本 6 地址记录）：包含域的 IPv6 地址的记录（与存储 IPv4 地址的 A 记录相反）。 
    
    CNAME（规范名称记录）：将一个域或子域转发到另一个域，不提供 IP 地址。 
    
    MX（邮件交换器记录）：将邮件定向到电子邮件服务器。 
    
    TXT（文本记录）：此记录允许管理员在记录中存储文本注释。 这些记录通常用于电子邮件安全。 
    
    NS（名称服务器记录）：存储 DNS 条目的名称服务器。 
    
    SOA（授权开始）：存储有关域的管理信息。 
    
    SRV（Service Location record）：指定特定服务的端口。 
    
    PTR（Reverse-lookup Pointer records）：在反向查找中提供域名。 
    
    CERT（证书记录）：存储公钥证书。


### Subdomain 子域

子域是我们主域名的附加部分。

它通常用于在逻辑上将网站分成几个部分。

我们可以在主域上创建多个子域或子域。


    例如，blog.example.com，其中 blog 是子域，example 是主域，.com 是顶级域 (TLD)。
    
    类似的示例可以是 support.example.com 或 careers.example.com。


###  DNS Zones DNS 区域

`DNS 区域`是域命名空间的一个独特部分，它被委托给负责维护 DNS 区域的法律实体，如个人、组织或公司。
DNS 区域也是一种管理功能，允许对 DNS 组件（例如权威名称服务器）进行精细控制。


### DNS Caching  DNS 缓存

DNS 缓存（有时称为 DNS 解析器缓存）是一个临时数据库，由计算机的操作系统维护，其中包含所有最近访问和尝试访问网站和其他 Internet 域的记录。
换句话说，DNS 缓存只是最近 DNS 查找的记忆，我们的计算机在试图弄清楚如何加载网站时可以快速参考它。

域名系统对每个 DNS 记录实施生存时间 (TTL)。
TTL 指定 DNS 客户端或服务器可以缓存记录的秒数。
当记录存储在缓存中时，它附带的任何 TTL 值也会被存储。
服务器继续更新缓存中存储的记录的 TTL，每秒倒计时。
当它达到零时，记录将被删除或从缓存中清除。 此时，如果收到对该记录的查询，则 DNS 服务器必须启动解析过程。


### Reverse DNS  反向域名解析

反向 DNS 查找是对与给定 IP 地址关联的域名的 DNS 查询。
这与更常用的正向 DNS 查找相反，后者查询 DNS 系统以返回 IP 地址。
反向解析 IP 地址的过程使用 PTR 记录。 如果服务器没有 PTR 记录，则无法解析反向查找。

电子邮件服务器通常使用反向查找。 电子邮件服务器在将电子邮件发送到其网络之前检查并查看电子邮件消息是否来自有效服务器。
许多电子邮件服务器会拒绝来自任何不支持反向查找的服务器或来自极不可能合法的服务器的邮件。

注意：反向 DNS 查找并未被普遍采用，因为它们对互联网的正常功能并不重要


### 一些广泛使用的托管 DNS 解决方案

    Route53
  
    Cloudflare DNS
  
    Google Cloud DNS
  
    Azure DNS
  
    NS1




<br>

---



## 负载均衡 Load Balance

`负载均衡`让我们可以在多个资源之间分配传入的网络流量，通过仅向在线资源发送请求来确保高可用性和可靠性,
这提供了根据需求增加或减少资源的灵活性

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/load-balancer.png)

为了获得额外的可扩展性和冗余，我们可以尝试在系统的每一层进行负载平衡

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/load-balancer-layers.png)



### 为什么要用负载均衡？




现代高流量网站必须为来自用户或客户端的数十万（如果不是数百万）并发请求提供服务。
为了经济高效地扩展以满足这些高容量，现代计算最佳实践通常需要添加更多服务器。

负载均衡器可以位于服务器前面，并在所有能够以最大化速度和容量利用率的方式满足这些请求的服务器之间路由客户端请求。
这确保没有单个服务器过度工作，这可能会降低性能。
如果单个服务器出现故障，负载均衡器会将流量重定向到其余在线服务器。
将新服务器添加到服务器组时，负载均衡器会自动开始向其发送请求

    负载平衡在防止停机方面也起着关键作用，

      负载平衡的其他优势包括： 

        可扩展性 
  
        冗余 
        
        灵活性 
        
        效率

### 工作负载分配  Workload distribution

这是负载均衡器提供的`核心功能`

有几个常见的变体：


    基于主机：根据请求的主机名分配请求。 
    
    基于路径：使用整个 URL 来分发请求，而不是仅仅使用主机名。 
    
    基于内容：检查请求的消息内容。 这允许基于诸如参数值之类的内容进行分发。



### 负载均衡器在 网络传输层 运行的级别



一般来说，负载均衡器在两个级别之一运行：

- `网络层` 这是在网络传输层（也称为第 4 层）工作的负载均衡器。
  它根据 IP 地址等网络信息执行路由，并且无法 执行基于内容的路由。
  这些通常是可以高速运行的专用硬件设备。

- `应用层` 这是在应用层（也称为第 7 层）运行的负载均衡器。
  负载均衡器可以完整读取请求并执行基于内容的路由。
  这允许基于对流量的全面了解来管理负载。


### 不同类型的负载均衡器


#### `Software` 软件负载平衡器

软件负载平衡器通常比硬件版本更容易部署。

它们也往往更具成本效益和灵活性，并且它们与软件开发环境结合使用。
软件方法使我们能够根据环境的特定需求灵活地配置负载平衡器。

灵活性的提升可能是以必须做更多工作来设置负载均衡器为代价的。

与提供更多封闭式方法的硬件版本相比，软件平衡器为我们提供了更多更改和升级的自由。

软件负载平衡器被广泛使用，既可以作为需要配置和管理的可安装解决方案使用，也可以作为托管云服务使用。

#### `Hardware` 硬件负载均衡器

硬件负载均衡器依赖物理的本地硬件来分配应用程序和网络流量。

这些设备可以处理大量流量，但通常价格不菲，而且在灵活性方面相当有限。

硬件负载平衡器包括专有固件，需要在发布新版本和安全补丁时进行维护和更新。

#### `DNS` DNS 负载平衡

DNS 负载平衡是在域名系统 (DNS) 中配置域的做法，以便客户端对域的请求分布在一组服务器计算机上。

不幸的是，DNS 负载平衡存在限制其可靠性和效率的固有问题。

最重要的是，DNS 不会检查服务器和网络中断或错误。

它总是为域返回同一组 IP 地址，即使服务器已关闭或无法访问也是如此。


### Routing Algorithms 路由算法


- `Round-robin`：请求轮流分发给应用服务器。

- `Weighted Round-robin`：建立在简单的 Round-robin 技术之上，使用管理员通过 DNS 记录分配的权重来考虑不同的服务器特性，例如计算和流量处理能力。

- `最少连接`：新请求发送到当前与客户端的连接最少的服务器。
  每台服务器的相对计算能力是确定哪台服务器连接最少的因素。

- `最短响应时间`：将请求发送到根据组合了最快响应时间和最少活动连接的公式选择的服务器。

- `最小带宽`：此方法以每秒兆位 (Mbps) 为单位测量流量，将客户端请求发送到流量最少 Mbps 的服务器。

- `散列`：根据我们定义的密钥分发请求，例如客户端 IP 地址或请求 URL。


### 冗余负载平衡器  Redundant load balancers

负载均衡器本身可能是单点故障。

为了克服这个问题，可以在集群模式下使用第二个或 N 个负载平衡器。

而且，如果有故障检测并且主动负载均衡器发生故障，另一个被动负载均衡器可以接管，这将使我们的系统更具容错性。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/redundant-load-balancer.png)


###  负载均衡器的一些常见功能


    自动缩放：根据需求情况启动和关闭资源。 
    
    粘性会话：将同一用户或设备分配给同一资源以维护资源上的会话状态的能力。 
    
    Healthchecks：确定资源是否关闭或性能不佳以便从负载平衡池中删除资源的能力。 
    
    持久连接：允许服务器打开与客户端（例如 WebSocket）的持久连接。 
    
    加密：处理加密连接，例如 TLS 和 SSL。 
    
    证书：向客户端出示证书并验证客户端证书。 
    
    压缩：压缩响应。 
    
    缓存：应用层负载均衡器可以提供缓存响应的能力。 
    
    日志记录：请求和响应元数据的日志记录可以用作重要的审计跟踪或分析数据的来源。 
    
    请求跟踪：为每个请求分配一个唯一的 ID，用于记录、监控和故障排除。 
    
    重定向：根据请求路径等因素重定向传入请求的能力。 
    
    固定响应：返回请求的静态响应，例如错误消息。




<br>


---




## Clustering 集群

在高层次上，`计算机集群`是一组两台或多台计算机或节点，它们`并行运行`以`实现共同目标`。

这允许由大量独立的、可并行的任务组成的工作负载分布在集群中的节点之间。

因此，这些任务可以利用每台计算机的组合内存和处理能力来提高整体性能。

要构建计算机集群，各个节点应连接到网络以启用节点间通信。

然后可以使用该软件将节点连接在一起并形成集群。 它可能在每个节点上都有一个共享存储设备和/或本地存储

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/cluster.png)


通常，至少有一个节点被指定为`领导节点`，并充当集群的`入口点`。
领导节点可能负责将传入的工作委派给其他节点，并在必要时聚合结果并将响应返回给用户。

理想情况下，一个集群就像一个单独的系统一样运行。
访问集群的用户不需要知道系统是集群还是单独的机器。
此外，集群的设计应尽量减少延迟并防止节点到节点通信中的瓶颈


### 集群计算的四个关键优势


    高可用性 

    可扩展性 
    
    性能 
    
    高性价比


###  计算机集群通常可以分为三种类型

    Highly available or fail-over  高可用性或故障转移  

    Load balancing  负载均衡

    High-performance computing  高性能计算


### 两种最常用的高可用性 (HA) 集群配置



#### Active-Active 双活


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/active-active.png)


`双活集群`通常由至少两个节点组成，两个节点同时主动运行相同类型的服务。

双活集群的主要目的是实现`负载均衡`。

负载均衡器将工作负载分配到所有节点，以防止任何单个节点过载。
因为有更多节点可供服务，吞吐量和响应时间也会有所改善。



#### Active-Passive 主动-被动

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/active-passive.png)

与主动-主动集群配置一样，主动-被动集群也由至少两个节点组成。
但是，正如名称主动-被动所暗示的那样，并非所有节点都将处于活动状态。
例如，在有两个节点的情况下，如果第一个节点已经处于活动状态，则第二个节点必须处于被动状态或处于备用状态。


### 负载平衡与集群

负载平衡与集群有一些共同的特征，但它们是不同的过程。

集群提供冗余并提高容量和可用性。 集群中的服务器相互了解并为共同的目的协同工作。

但是通过负载平衡，服务器之间并不知道彼此。 相反，他们对从负载均衡器收到的请求做出反应。
我们可以将负载平衡与集群结合使用，但它也适用于涉及具有共同目的的独立服务器的情况，例如运行网站、业务应用程序、Web 服务或其他一些 IT 资源。


### 集群的复杂性


集群带来的最明显的挑战是安装和维护的复杂性增加。
必须在每个节点上分别安装和更新操作系统、应用程序及其依赖项。

如果集群中的节点不是同类的，这会变得更加复杂。 还必须密切监视每个节点的资源利用率，并汇总日志以确保软件运行正常。

此外，存储变得更难管理，共享存储设备必须防止节点相互覆盖，分布式数据存储必须保持同步。


<br>

---



## Caching 缓存


`缓存`的主要目的是通过减少访问底层较慢存储层的需要来`提高数据检索性能`。

`以容量换取速度`，缓存通常会暂时存储数据的子集，这与数据通常是完整且持久的数据库不同。

缓存利用了局部引用原则 “`最近请求的数据很可能会被再次请求`”。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/caching.png)


###  缓存和内存

类似于计算机的内存，高速缓存是一种紧凑、快速的内存，它以层次结构存储数据，
从第一层开始，然后从那里按顺序进行。 它们被标记为 L1、L2、L3 等。
如果请求，缓存也会被写入，例如当有更新并且需要将新内容保存到缓存中时，替换已保存的旧内容。

无论缓存是读还是写，都是一次一个块地完成。 每个块还有一个标签，其中包含数据在缓存中的存储位置。
当从缓存中请求数据时，会通过标签进行搜索，以查找内存一级 (L1) 中所需的特定内容。
如果未找到正确的数据，则会在 L2 中进行更多搜索。

如果在那里找不到数据，则在 L3 中继续搜索，然后是 L4，依此类推，直到找到为止，然后读取并加载它。
如果在缓存中根本找不到数据，则会将其写入缓存中以便下次快速检索。


### 缓存命中和缓存未命中


#### 缓存命中

`缓存命中`描述了从缓存中成功提供内容的情况。
标签在内存中快速搜索，当找到并读取数据时，它被认为是缓存命中。

> 冷缓存、温缓存和热缓存

缓存命中也可以描述为`冷缓存、温缓存或热缓存`。 在每一个中，都描述了读取数据的速度。

`热缓存`是以尽可能快的速度从内存中读取数据的实例。
当从 L1 检索数据时会发生这种情况。

`冷缓存`是读取数据的最慢速率，但它仍然是成功的，因此仍被视为缓存命中。
数据只是在内存层次结构中较低的位置（例如 L3 或更低）中找到。

`暖缓存`用于描述在 L2 或 L3 中找到的数据。 它不如热缓存快，但仍然比冷缓存快。
通常，将缓存称为暖缓存用于表示它比热缓存更慢且更接近冷缓存。


#### 缓存未命中

缓存未命中是指搜索内存但找不到数据的实例。发生这种情况时，内容将被传输并写入缓存。



###  缓存失效

`缓存失效`是计算机系统将缓存条目声明为无效并删除或替换它们的过程。

如果数据被修改，它应该在缓存中失效，否则，这会导致不一致的应用程序行为。

三种缓存系统

#### Write-through cache 直写缓存

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-through-cache.png)


数据`同时`写入缓存和对应的数据库。


    优点：快速检索，缓存和存储之间的数据完全一致
    
    缺点：写入操作的延迟更高。


#### Write-around cache 饶写缓存

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-around-cache.png)

直接写到数据库或永久存储的地方，绕过缓存。

    优点：这可能会减少延迟。
    
    缺点：它增加了缓存未命中，因为缓存系统必须在缓存未命中的情况下从数据库中读取信息。 
         因此，对于快速写入和重新读取信息的应用程序，这可能会导致更高的读取延迟。 
         读取发生在较慢的后端存储中，并经历较高的延迟。


#### Write-back cache 回写缓存

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-back-cache.png)

其中只对缓存层进行写入，写入缓存完成后立即确认写入。 然后缓存将此写入异步同步到数据库。

    优点：这将减少写入密集型应用程序的延迟并提高吞吐量。 
    
    缺点：如果缓存层崩溃，则存在数据丢失的风险。 
        我们可以通过让多个副本确认缓存中的写入来改进这一点。




<br>

---




## Content Delivery Network (CDN)  内容分发网络 (CDN)


内容分发网络 (CDN) 是一组地理分布的服务器，它们协同工作以提供 Internet 内容的快速分发。
通常，HTML/CSS/JS、照片和视频等静态文件由 CDN 提供

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/content-delivery-network/cdn-map.png)



### 为什么要使用 CDN?


内容交付网络 (CDN) 提高了内容可用性和冗余度，同时降低了带宽成本并提高了安全性。

从 CDN 提供内容可以显着提高性能，因为用户从靠近他们的数据中心接收内容，而我们的服务器不必为 CDN 满足的请求提供服务。



### CDN 工作模式

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/content-delivery-network/cdn.png)

在 CDN 中，源服务器包含内容的原始版本，而边缘服务器数量众多，分布在世界各地。

为了最大程度地缩短访问者与网站服务器之间的距离，CDN 将其内容的缓存版本存储在多个称为边缘位置的地理位置。

每个边缘位置都包含许多缓存服务器，负责向其附近的访问者提供内容。

一旦静态资产缓存在特定位置的所有 CDN 服务器上，所有后续网站访问者对静态资产的请求都将从这些边缘服务器而不是源站传递，从而减少源站负载并提高可扩展性。

    例如，当英国的某个人请求我们可能在美国托管的网站时，他们将从最近的边缘位置（例如伦敦边缘位置）获得服务。 
    这比让访问者向源服务器发出完整请求要快得多，后者会增加延迟。


### CDN一般分为两种：



#### Push CDNs

每当服务器上发生更改时，推送 CDN 都会接收新内容。
我们全权负责提供内容，直接上传到 CDN，重写 URL 指向 CDN。
我们可以配置内容何时过期以及何时更新。 仅当内容是新的或更改时才上传，最大限度地减少流量，但最大限度地增加存储空间。
具有少量流量的站点或内容不经常更新的站点与推送 CDN 配合得很好。
内容只放置在 CDN 上一次，而不是定期重新拉取。


#### Pull CDN

在拉取 CDN 的情况下，缓存根据请求进行更新。
当客户端发送一个请求，要求从 CDN 获取静态资源，如果 CDN 没有，那么它会从源服务器获取新更新的资源，
并用这个新资源填充它的缓存，然后发送这个 新的缓存资产给用户。
与 Push CDN 相反，这需要较少的维护，因为 CDN 节点上的缓存更新是根据客户端对源服务器的请求执行的。
流量大的站点与拉取式 CDN 配合得很好，因为流量分布更均匀，只有最近请求的内容保留在 CDN 上。


###  缺点

众所周知，好事伴随着额外的成本，所以让我们讨论一下 CDN 的一些缺点：

    额外费用：使用 CDN 可能很昂贵，尤其是对于高流量服务。 
    
    限制：一些组织和国家已经阻止了流行的 CDN 的域或 IP 地址。 
    
    位置：如果我们的大多数观众位于 CDN 没有服务器的国家/地区，则我们网站上的数据可能需要比不使用任何 CDN 时传输得更远。



<br>

---



## Proxy 代理

`代理服务器`是位于客户端和后端服务器之间的`硬件/软件中间件`。

它接收来自客户端的请求并将它们中继到源服务器。

通常，代理用于`过滤请求`、`记录请求`或有时`转换请求（通过添加/删除标头、加密/解密或压缩）`。


### 两种类型的代理


#### Forward Proxy 正向代理

`正向代理`通常称为代理、代理服务器或 Web 代理，是位于一组客户端计算机前面的服务器。

当这些计算机向 Internet 上的站点和服务发出请求时，代理服务器会拦截这些请求，然后像中间人一样代表这些客户端与 Web 服务器通信。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/proxy/forward-proxy.png)


正向代理的一些优点：

    阻止访问某些内容 
    
    允许访问受地理限制的内容 
    
    提供匿名性 
    
    避免其他浏览限制 

尽管代理提供匿名的好处，但它们仍然可以跟踪我们的个人信息。 代理服务器的设置和维护成本高昂且需要配置


#### Reverse Proxy 反向代理


`反向代理`是位于一个或多个 Web 服务器前面的服务器，拦截来自客户端的请求。

当客户端向网站的源站服务器发送请求时，这些请求会被反向代理服务器拦截。


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/proxy/reverse-proxy.png)


反向代理的一些优点：

    提高安全性 
    
    缓存 
    
    SSL加密 
    
    负载均衡 
    
    可扩展性和灵活性


### 负载均衡器 vs 反向代理


当我们有多个服务器时，负载均衡器很有用。

通常，负载平衡器将流量路由到一组服务相同功能的服务器，而反向代理即使只有一个 Web 服务器或应用程序服务器也很有用。

反向代理也可以充当负载均衡器，但反之则不行





<br>

---




## Availability  可用性

`可用性`是系统在特定时期内保持运行以执行其所需功能的时间。
它是对系统、服务或机器在正常条件下保持运行的时间百分比的简单度量。


如果可用性为 99.00%，则称其可用性为“2 个 9”，如果为 99.9%，则称为“3 个 9”，依此类推。

<br>

---


<br>

---



## Scalability  可扩展性

`可扩展性`是衡量系统通过添加或删除资源来满足需求来响应变化的能力。


### Vertical scaling  垂直缩放

垂直扩展（也称为向上扩展）通过为现有机器增加更多功能来扩展系统的可扩展性。
换句话说，垂直扩展是指通过`增加硬件容量`来提高应用程序的能力。

优点

    易于实施
    更易于管理
    数据一致
    缺点
    停机时间长的风险
    更难升级
    可能是单点故障



### Horizontal scaling 水平缩放


水平扩展（也称为向外扩展）通过添加更多机器来扩展系统的规模。
它通过向现有服务器池`添加更多实例`来提高服务器性能，从而使负载分布更均匀。

优点

    增加冗余
    更好的容错能力
    灵活高效
    更容易升级
    缺点
    增加复杂性
    数据不一致
    增加下游服务的负载



<br>

---


<br>

---


##  Storage  存储

`存储`是一种使系统能够临时或永久保留数据的机制。



### RAID

RAID (Redundant Array of Independent Disks)（独立磁盘冗余阵列）是一种将相同数据存储在多个硬盘或固态驱动器
(SSD) 上以在驱动器发生故障时保护数据的方法。


> 一些常用的 RAID 级别:

    RAID 0：也称为条带化，数据在阵列中的所有驱动器之间平均分配。
    
    RAID 1：也称为镜像，至少两个驱动器包含一组数据的精确副本。 如果一个驱动器出现故障，其他驱动器仍然可以工作。
    
    RAID 5：带奇偶校验的条带化。 需要使用至少 3 个驱动器，像 RAID 0 一样跨多个驱动器条带化数据，但也有跨驱动器分布的奇偶校验。
    
    RAID 6：带双重奇偶校验的条带化。 RAID 6 类似于 RAID 5，但奇偶校验数据写入两个驱动器。
    
    RAID 10：结合了 RAID 0 和 RAID 1 的条带化和镜像。它通过在辅助驱动器上镜像所有数据来提供安全性，同时在每组驱动器上使用条带化来加速数据传输。RAID 0：也称为条带化，数据在阵列中的所有驱动器之间平均分配。


### Volumes 卷

`卷`是磁盘或磁带上的固定存储量。
术语卷通常用作存储本身的同义词，但单个磁盘可能包含多个卷或一个卷跨越多个磁盘


### File storage  文件存储


`文件存储`是一种将数据存储为文件并将其作为分层目录结构呈现给最终用户的解决方案。

主要优点是提供一个用户友好的解决方案来存储和检索文件。

要在文件存储中定位文件，需要文件的完整路径。

它经济实惠且结构简单，通常位于硬盘驱动器上，这意味着它们对用户和硬盘驱动器的显示完全相同。

    示例：Amazon EFS、Azure 文件、Google Cloud Filestore 等。


### Block storage 块存储


`块存储`将数据分成块（块）并将它们存储为单独的块。

每个数据块都有一个唯一的标识符，这允许存储系统将较小的数据块放在最方便的地方。

块存储还将数据与用户环境分离，允许数据分布在多个环境中。

这会创建多个数据路径，并允许用户快速检索数据。

当用户或应用程序向块存储系统请求数据时，底层存储系统重新组合数据块并将数据呈现给用户或应用程序

    示例：亚马逊 EBS。


### Object Storage 对象存储


`对象存储`，也称为基于对象的存储，将数据文件分解为称为对象的片段。

然后它将这些对象存储在一个存储库中，该存储库可以分布在多个联网系统中。

    示例：Amazon S3、Azure Blob Storage、Google Cloud Storage 等。

### NAS 网络附加存储


`NAS（网络附加存储）`是连接到网络的存储设备，允许授权网络用户从中央位置存储和检索数据。


NAS 设备是灵活的，这意味着当我们需要额外的存储空间时，我们可以添加到现有的空间中。


它速度更快、成本更低，并提供现场公共云的所有优势，让我们能够完全控制。


### 硬盘文件系统 HDFS (`The Hadoop Distributed File System`)

`Hadoop 分布式文件系统 (HDFS)` 是一种分布式文件系统，旨在在商用硬件上运行。

HDFS 具有高度容错性，旨在部署在低成本硬件上。

HDFS 提供对应用程序数据的高吞吐量访问，适用于具有大型数据集的应用程序。

它与现有的分布式文件系统有很多相似之处。

HDFS 旨在跨大型集群中的机器可靠地存储非常大的文件。

它将每个文件存储为一系列块，文件中除最后一个块外的所有块都具有相同的大小, 复制文件的块以实现容错。



<br>

---


<br>

---


# Chapter II 数据库





<br>

---


## Databases and DBMS 数据库和数据库管理系统



### 什么是数据库?

`数据库`是结构化信息或数据的有组织集合，通常以电子方式存储在计算机系统中。 


数据库通常由`数据库管理系统 (DBMS)` 控制。 

`数据`和 `DBMS` 以及`与之关联的应用程序`一起称为`数据库系统`，通常简称为`数据库`



### 什么是数据库管理系统? DBMS


数据库通常需要一个称为`数据库管理系统 (DBMS)` 的综合数据库软件程序。

DBMS 充当数据库与其最终用户或程序之间的接口，允许用户检索、更新和管理信息的组织和优化方式。

DBMS 还有助于监督和控制数据库，支持各种管理操作，例如性能监控、调整以及备份和恢复。



### 数据库中一些常见组件



#### Schema

定义数据结构的形状，并指定什么样的数据可以去哪里。 

`Schema`可以在整个数据库中严格执行，也可以在数据库的一部分上松散地执行，或者它们可能根本不存在。



#### Table

每个表都包含各种列，就像在电子表格中一样。 

一个表可以只有两列，也可以有一百或更多列，这取决于表中放置的信息类型。


#### Column

一列包含一组特定类型的数据值，一个值代表数据库的每一行。

一列可能包含文本值、数字、枚举、时间戳等。


#### Row

表中的数据记录在行中。 

表中可能有数千或数百万行具有任何特定信息。



### 大规模运行数据库时面临的一些常见挑战

- 吸收数据量的显着增加：


      来自传感器、联网机器和许多其他来源的数据呈爆炸式增长。


- 确保数据安全：
  

       如今，数据泄露无处不在，确保数据安全且用户易于访问比以往任何时候都更加重要。


- 跟上需求：


      公司需要实时访问他们的数据以支持及时的决策制定并利用新的机会。


- 管理和维护数据库和基础设施：
  

      随着数据库变得越来越复杂和数据量的增长，公司面临着雇用额外人才来管理其数据库的费用。



- 消除对可扩展性的限制：
  

    企业要想生存就需要发展，其数据管理也必须随之发展。 但是很难预测公司需要多少容量，尤其是本地数据库。


- 确保数据驻留、数据主权或延迟要求：
  

    一些组织的用例更适合在本地运行。 在这些情况下，为运行数据库而预先配置和预先优化的工程系统是理想的。



### 数据库 类型


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/databases-and-dbms/database-types.png)


- SQL

- NoSQL
    

    Document

    Key-value

    Graph

    Timeseries

    Wide column

    Multi-model





## SQL databases



SQL（或关系型）数据库是数据项的集合，它们之间具有预定义的关系。 

这些项目被组织为一组包含列和行的表格。 表用于保存有关要在数据库中表示的对象的信息。 
表中的每一列都包含某种数据，字段存储属性的实际值。 表中的行表示一个对象或实体的相关值的集合。

表中的每一行都可以用一个称为主键的唯一标识符来标记，并且多个表之间的行可以使用外键进行关联。
这些数据可以通过多种不同的方式访问，而无需重新组织数据库表本身。

SQL 数据库通常遵循 `ACID 一致性`模型。



### Materialized views  实体化视图

实体化视图是从查询规范派生并存储以备后用的预先计算的数据集。
因为数据是预先计算的，所以查询物化视图比对视图的基表执行查询更快。 
当查询频繁运行或足够复杂时，这种性能差异可能会很明显。

它还支持数据子集化并提高在大型数据集上运行的复杂查询的性能，从而减少网络负载。 
物化视图还有其他用途，但它们主要用于性能和复制。


### N+1查询问题

N+1 查询问题发生在数据访问层执行 N 个额外的 SQL 语句以获取在执行主 SQL 查询时可能已检索到的相同数据时。 
N的值越大，执行的查询越多，对性能的影响越大。

这在 GraphQL 和 ORM（对象关系映射）工具中很常见，可以通过优化 SQL 查询或使用数据加载器来解决，
该数据加载器对连续请求进行批处理并在后台发出单个数据请求。


###  优缺点


优点

    简单准确
    辅助功能
    数据一致性
    灵活性


缺点
    
    维护费用昂贵
    困难的模式演变
    性能命中（连接、非规范化等）
    水平可扩展性差，难以扩展



### 例子


    PostgreSQL

    MySQL

    MariaDB

    Amazon Aurora




## NoSQL databases

`NoSQL` 是一个广泛的类别，包括不使用 SQL 作为其主要数据访问语言的任何数据库。 
这些类型的数据库有时也称为非关系数据库。 

与关系数据库不同，NoSQL 数据库中的数据不必符合预定义的模式。 
NoSQL 数据库遵循 `BASE 一致性`模型。


### 不同类型的 NoSQL 数据库：


#### Document

文档数据库（也称为面向文档的数据库或文档存储）是一种在文档中存储信息的数据库。 

它们是通用数据库，服务于交易和分析应用程序的各种用例。

优点

    直观灵活

    简单的水平缩放

    无模式


缺点
    
    无模式

    非关系型


例子

    MongoDB

    Amazon DocumentDB

    CouchDB


### Key-value


作为最简单的 NoSQL 数据库类型之一，`键值数据库`将数据保存为一组键值对，每个键值对由两个数据项组成。

它们有时也被称为`键值存储`。


优点

    简单而高效
    高度可扩展以应对大量流量
    会话管理
    优化查找


缺点
    
    基本增删改查
    无法过滤值
    缺乏索引和扫描功能
    未针对复杂查询进行优化

例子

  
    Redis

    Memcached

    Amazon DynamoDB

    Aerospike



###  Graph

`图数据库`是一种 NoSQL 数据库，它使用图结构进行具有节点、边和属性的语义查询来表示和存储数据，而不是表或文档。

该图将存储中的数据项与节点和边的集合相关联，边表示节点之间的关系。 

这些关系允许商店中的数据直接链接在一起，并且在许多情况下，可以通过一次操作进行检索。



优点

    查询速度
    敏捷灵活
    显式数据表示


缺点

    复杂的
    没有标准化的查询语言


用例

    欺诈识别

    推荐引擎

    社交网络

    网络映射


例子
    
    Neo4j

    ArangoDB

    Amazon Neptune

    JanusGraph




###  Time series

`时间序列数据库`是针对时间戳或时间序列数据优化的数据库。


优点
  
    快速插入和检索
    高效的数据存储

用例
    
    物联网数据

    指标分析

    应用监控

    了解金融趋势

例子

    
    InfluxDB

    Apache Druid



### Wide column



`宽列数据库`，也称为宽列存储，与模式无关。

数据存储在列族中，而不是行和列中。



优点

    高度可扩展，可以处理 PB 级数据
    实时大数据应用的理想选择

缺点
    
    昂贵的
    增加写入时间


用例

    商业分析

    基于属性的数据存储


例子

    BigTable

    Apache Cassandra

    ScyllaDB



### Multi-model


`多模型数据库`将不同的数据库模型（即关系、图形、键值、文档等）组合到一个集成的后端中。

这意味着它们可以适应各种数据类型、索引、查询，并将数据存储在多个模型中


优点

    灵活性
    适用于复杂项目
    数据一致


缺点

    复杂的
    不太成熟

例子
    
    ArangoDB

    Azure Cosmos DB

    Couchbase




<br>

---


## SQL vs NoSQL databases  SQL 与 NoSQL 数据库

在数据库世界中，有两种主要类型的解决方案，SQL（关系型）和 NoSQL（非关系型）数据库。 

它们的构建方式、存储的信息类型以及存储信息的方式都不同。 

关系数据库是结构化的并且具有预定义的模式，而非关系数据库是非结构化的、分布式的并且具有动态模式。


### SQL 和 NoSQL 之间的一些高级差异 


#### Storage 存储


SQL 将数据存储在表中，其中每一行代表一个实体，每一列代表关于该实体的一个数据点。

NoSQL数据库有键值、图、文档等不同的数据存储模型。


#### Schema 

在 SQL 中，每条记录都符合一个固定的模式，这意味着必须在输入数据之前决定和选择列，并且每行必须有每一列的数据。
模式可以稍后更改，但它涉及使用迁移修改数据库。

而在 NoSQL 中，模式是动态的。 可以即时添加列，每一行（或等效行）不必包含每一列的数据。


#### Querying

SQL 数据库使用 SQL（结构化查询语言）来定义和操作数据，功能非常强大。

在 NoSQL 数据库中，查询集中在文档集合上。 不同的数据库有不同的查询语法。


#### Scalability 扩展性

在大多数常见情况下，SQL 数据库是`垂直可扩展`的，这可能会变得非常昂贵。
跨多个服务器扩展关系数据库是可能的，但这是一个具有挑战性且耗时的过程。

另一方面，NoSQL 数据库是`横向可扩展`的，这意味着我们可以轻松地向我们的 NoSQL 数据库基础架构添加更多服务器来处理大流量。 

任何廉价的商品硬件或云实例都可以托管 NoSQL 数据库，因此比垂直扩展更具成本效益。
许多 NoSQL 技术还自动跨服务器分发数据。


#### Reliability 可靠性

绝大多数关系数据库都符合 ACID。
因此，就数据可靠性和执行事务的安全保证而言，SQL 数据库仍然是更好的选择。

大多数 NoSQL 解决方案为了性能和可扩展性而牺牲了 ACID 合规性。






### 选择 SQL NoSQL的原因

对于 SQL

    具有严格模式的结构化数据

    关系数据

    需要复杂的连接

    交易

    按索引查找非常快


对于 NoSQL
    
    动态或灵活的模式

    非关系数据

    不需要复杂的连接

    数据密集型工作负载

    非常高的 IOPS 吞吐量


<br>

---


##  数据库同步，复制

复制是一个涉及共享信息以确保冗余资源（例如多个数据库）之间的一致性，以提高可靠性、容错性或可访问性的过程。


### 主从复制 Master-Slave Replication

master 提供读写服务，将写入复制到一个或多个仅提供读取服务的 slave。 从站还可以以树状方式复制其他从站。

如果 master 离线，系统可以继续以只读模式运行，直到一个 slave 被提升为 master 或提供一个新的 master。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/database-replication/master-slave-replication.png)


优点
    
    整个数据库的备份对master相对没有影响。

    应用程序可以在不影响主服务器的情况下从从服务器读取数据。

    从站可以脱机并同步回主站，而无需停机。


缺点

    复制增加了更多的硬件和额外的复杂性。

    主机故障时的停机时间和可能的数据丢失。

    所有写入也必须在主从架构中对主服务器进行。

    读从机越多，我们要复制的越多，这会增加复制滞后。



### 主-主复制 Master-Master Replication


两个 master 都提供读/写服务并相互协调。 

如果任一主节点出现故障，系统可以继续进行读写操作。


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/database-replication/master-master-replication.png)


优点

    
    应用程序可以从两个主机读取。

    在两个主节点之间分配写入负载。

    简单、自动且快速的故障转移。


缺点

    
    不像主从配置部署那么简单。

    松散一致或由于同步而增加了写入延迟。

    随着更多写入节点的添加和延迟的增加，冲突解决开始发挥作用。



### 同步与异步复制 Synchronous vs Asynchronous replication


同步和异步复制之间的主要区别在于数据写入副本的方式。 

在`同步复制`中，数据同时写入主存储和副本。 因此，主副本和副本应始终保持同步。

相反，`异步复制`在数据已写入主存储后将数据复制到副本。 
尽管复制过程可能会近乎实时地进行，但按计划进行复制更为常见，并且更具成本效益。





<br>

---


## 索引 Indexes


当涉及到数据库时，`索引`是众所周知的，它们用于提高数据存储上的数据检索操作的速度。

索引在`增加存储开销和较慢的写入`（因为我们不仅要写入数据而且还必须更新索引）以`换取更快的读取`之间进行权衡。 

索引用于快速定位数据，而无需检查数据库表中的每一行。 

可以使用数据库表的一列或多列创建索引，为快速随机查找和高效访问有序记录提供基础。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/indexes/indexes.png)


索引是一种数据结构，可以将其视为`目录`，将我们指向实际数据所在的位置。

因此，当我们在表的列上创建索引时，我们将该列和指向整行的指针存储在索引中。 

索引还用于创建相同数据的不同视图。 对于大型数据集，这是指定不同过滤器或排序方案的绝佳方式，
而无需求助于创建多个额外的数据副本。



>数据库索引的一个特性是它们可以是`密集`的或`稀`疏的。  这些指数质量中的每一个都有其自身的权衡。


### Dense Index

在`密集索引`中，为表的每一行创建一个索引记录。

记录可以直接定位，因为索引的每个记录都包含搜索关键字值和指向实际记录的指针。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/indexes/dense-index.png)

在写入时，密集索引比稀疏索引需要更多维护。 由于每一行都必须有一个条目，因此数据库必须在插入、更新和删除时维护索引。 
每行都有一个条目也意味着密集索引将需要更多内存。 密集索引的好处是可以通过二进制搜索快速找到值。 密集索引也不对数据强加任何排序要求。


### Sparse Index

在稀疏索引中，仅为部分记录创建记录。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/indexes/sparse-index.png)

稀疏索引在写入时比密集索引需要更少的维护，因为它们只包含值的一个子集。 这种较轻的维护负担意味着插入、更新和删除会更快。 
拥有更少的条目也意味着索引将使用更少的内存。 查找数据速度较慢，因为跨页面扫描通常遵循二进制搜索。 在处理有序数据时，稀疏索引也是可选的。



<br>

---


## Normalization and Denormalization  规范化和反规范化



### 规范化和反规范化中的一些常用术语


#### Keys 键


`Primary key` 主键：可用于唯一标识表中每一行的列或列组。

`Composite key` 复合键：由多个列组成的主键。

`Super key` 超级键：可以唯一标识表中存在的所有行的所有键的集合。

`Candidate key` 候选键：在表中唯一标识行的属性。

`Foreign key` 外键：它是对另一个表的主键的引用。

`Alternate key` 备用键：不是主键的键称为备用键。

`Surrogate key` 代理键：当没有其他列能够保存主键的属性时，系统生成的值可以唯一标识表中的每个条目。


#### Dependencies 依赖关系 


`Partial dependency` 部分依赖：发生在主键决定其他一些属性时。

`Functional dependency` 功能依赖：它是存在于两个属性之间的关系，通常是表中的主键和非键属性之间。

`Transitive functional dependency` 传递函数依赖：当一些非关键属性决定其他一些属性时发生。


#### Anomalies 异常现象

当由于不正确的计划或将所有内容存储在平面数据库中而导致数据库存在缺陷时，就会发生数据库异常。
这通常通过规范化过程来解决。


`Insertion anomaly` 插入异常：当我们无法在没有其他属性存在的情况下将某些属性插入数据库时发生。

`Update anomaly` 更新异常：发生在数据冗余和部分更新的情况下。 换句话说，数据库的正确更新需要其他操作，例如添加、删除或两者。

`Deletion anomaly` 删除异常：发生在删除某些数据需要删除其他数据的情况下。


### Normalization 规范化


规范化是在数据库中组织数据的过程。

这包括根据旨在保护数据和通过消除冗余和不一致的依赖性使数据库更加灵活的规则来创建表和在这些表之间建立关系


#### 为什么需要规范化

规范化的目标是`消除冗余数据`，`保证数据的一致性`。 

完全规范化的数据库允许扩展其结构以容纳新类型的数据，而无需过多更改现有结构。
因此，与数据库交互的应用程序受到的影响最小。


####  Normal forms  范式

范式是一系列确保数据库规范化的准则


- `1NF` 第一范式


    不允许重复组。
  
    用主键标识每组相关数据。
  
    一组相关数据应该有一个单独的表。
  
    不允许在同一列中混合数据类型



- `2NF` 第二范式


    满足第一范式 (1NF)

    不应该有任何部分依赖




- `3NF` 第三范式


    满足第二范式 (2NF)。

    传递函数依赖是不允许的



- `BCNF` Boyce-Codd 范式

`Boyce-Codd 范式`（或 BCNF）是第三范式 (3NF) 的稍强版本，用于解决最初定义的 3NF 未处理的某些类型的异常。
有时也称为 `3.5 范式` (3.5NF)。

    满足第三范式（3NF）

    对于每个函数依赖 X → Y，X 应该是超级键


- ...


在关系数据库中，如果关系满足第三范式，则通常将其描述为`“规范化”`。

    大多数 3NF 关系没有插入、更新和删除异常。


与许多正式的规则和规范一样，现实世界的场景并不总是允许完美合规。 

如果您决定违反规范化的前三个规则之一，请确保您的应用程序预见到可能发生的任何问题，
例如冗余数据和不一致的依赖关系。


#### 优缺点



优点

    减少数据冗余。
    更好的数据设计。
    提高数据一致性。
    强制参照完整性。


缺点


    数据设计很复杂。
    性能较慢。
    维护开销。
    需要更多的连接。






### Denormalization 反规范化


非规范化是一种数据库优化技术，我们将`冗余数据`添加到一个或多个表中。 

这可以帮助我们`避免在关系数据库中进行代价高昂的连接`。 

它试图以牺牲一些写入性能为代价来提高读取性能。 数据的冗余副本写入多个表以避免昂贵的连接。


一旦数据通过联合和分片等技术分布，跨网络管理连接会进一步增加复杂性。 
非规范化可能会避免对此类复杂连接的需求。



> 注意：反规范化并不意味着反转规范化(`reversing normalization`)


#### 优缺点


优点
    
    检索数据更快。
    编写查询更容易。
    减少表的数量。
    便于管理。


缺点
    
    昂贵的插入和更新。
    增加数据库设计的复杂性。
    增加数据冗余。
    数据不一致的可能性更大。


<br>

---


## ACID and BASE consistency models  `ACID` 和 `BASE` 一致性模型



### ACID 

`ACID` 代表`原子性、一致性、隔离性和持久性`。 ACID 属性用于在事务处理期间维护数据完整性。

为了保持`事务前后的一致性`，关系数据库遵循 ACID 属性


####  原子 Atomic

事务中的所有操作都成功或每个操作都被回滚。

#### 持续的 Consistent

事务完成后，数据库在结构上是健全的。

#### 隔离的 Isolated

事务不相互竞争。 对数据的有争议的访问由数据库进行调节，以便事务看起来是按顺序运行的。

#### 耐用的 Durable

一旦事务已经完成，写入和更新已经写入磁盘，即使发生系统故障，它也会保留在系统中。



### BASE

随着数据量和高可用性要求的增加，数据库设计方法也发生了巨大变化。
为了提高扩展能力并同时保持高可用性，我们将逻辑从数据库移至单独的服务器。
这样，数据库变得更加独立，专注于存储数据的实际过程。

在 `NoSQL 数据库`世界中，ACID 事务不太常见，
因为一些数据库放宽了对即时一致性、数据新鲜度和准确性的要求，以获得其他好处，如规模和弹性。


BASE 属性比 ACID 保证宽松得多，但是两个一致性模型之间没有直接的一对一映射


####  基本可用性 Basic Availability 

数据库似乎大部分时间都在工作。

#### 软状态 Soft-state

存储不必写一致，不同的副本也不必始终相互一致。

#### 最终一致性 Eventual consistency

数据可能不会立即一致，但最终会变得一致。
系统中的读取仍然是可能的，即使它们可能由于不一致而无法给出正确的响应。





### `ACID `与 `BASE` 的权衡

对于我们的应用程序需要 ACID 还是 BASE 一致性模型，没有正确的答案。
这两种模型的设计都是为了满足不同的要求。 
在选择数据库时，我们需要牢记模型的属性和应用程序的要求


考虑到 BASE 的松散一致性，如果开发人员为他们的应用程序选择 BASE 存储，
则他们需要对一致性数据有更多的了解和严格。 必须熟悉所选数据库的 BASE 行为并在这些约束下工作。

另一方面，与 ACID 事务的简单性相比，围绕 BASE 限制进行规划有时可能是一个主要缺点。
完全 ACID 数据库非常适合数据可靠性和一致性至关重要的用例



<br>

---


##  `分布式系统` CAP Theorem (`Consistency`, `Availability`,`Partition tolerance`)

`CAP 定理`指出，分布式系统只能提供`一致性`、`可用性`和`分区容错性` (CAP) 这三个所需特性中的两个

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/cap-theorem/cap-theorem.png)


###  CAP定理所指的三个分布式系统特性

#### 一致性 Consistency

一致性意味着所有客户端同时看到相同的数据，无论它们连接到哪个节点。
为此，无论何时将数据写入一个节点，都必须在写入被视为“成功”之前立即转发或复制到系统中的所有节点。


#### 可用性 Availability

可用性意味着任何发出数据请求的客户端都会得到响应，即使一个或多个节点已关闭。


#### 分区容差 Partition tolerance

分区容错意味着系统在消息丢失或部分故障的情况下继续工作。 
分区容错的系统可以承受任何数量的网络故障，但不会导致整个网络出现故障。
跨节点和网络的组合充分复制数据，以在间歇性中断期间保持系统正常运行。


### 一致性-可用性 Consistency-Availability  权衡 

物理世界中，无法保证网络的稳定性，所以分布式数据库必须选择`Partition Tolerance（P）`。

这意味着需要在`一致性 (C) `和`可用性 (A)` 之间进行权衡。



#### CA 数据库

CA 数据库提供跨所有节点的一致性和可用性。
如果系统中任意两个节点之间存在分区，则无法执行此操作，因此无法提供容错。

    示例：PostgreSQL、MariaDB。

#### CP数据库

CP 数据库以可用性为代价提供一致性和分区容错性。 
当任意两个节点之间发生分区时，系统必须关闭不一致的节点，直到分区解决。

    示例：MongoDB、Apache HBase。

#### AP数据库

AP 数据库以一致性为代价提供可用性和分区容错性。
发生分区时，所有节点都保持可用，但分区错误端的节点可能会返回比其他节点更旧的数据版本。 
分区解决后，AP 数据库通常会重新同步节点以修复系统中的所有不一致。

    示例：Apache Cassandra、CouchDB。


<br>

---


##  `分布式系统` PACELC Theorem 

`PACELC 定理`是 `CAP 定理`的扩展。

`CAP 定理`指出，在分布式系统中的网络分区 (P) 的情况下，必须在可用性 (A) 和一致性 (C) 之间做出选择。

`PACELC` 通过引入`延迟 (L)` 作为分布式系统的附加属性来`扩展 CAP 定理`。 
该定理指出，`否则（E）`，即使系统在`没有分区的情况下`正常运行，也必须在`延迟（L）`和`一致性（C）`之间做出选择


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/pacelc-theorem/pacelc-theorem.png)



`PACELC 定理`的开发是为了解决 CAP 定理的一个关键限制，因为它没有对性能或延迟做出规定。

    例如，
      根据 CAP 定理，如果查询在 30 天后返回响应，则可以认为数据库可用。 
      显然，对于任何现实世界的应用程序来说，这样的延迟都是不可接受的


<br>

---


##  Transaction 事务 


`事务`是被视为“单个工作单元”的一系列数据库操作。 

事务中的操作要么全部成功，要么全部失败。 

这样，事务的概念在系统的一部分出现故障时`支持数据完整性`。 

并非所有数据库都选择支持 `ACID 事务`，通常是因为它们优先考虑其他难以或理论上无法一起实施的优化。

通常，关系型数据库支持ACID事务，非关系型数据库不支持（也有例外）。


### 事务的状态 States


数据库中的事务可以处于以下状态

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/transactions/transaction-states.png)



#### Active

在这种状态下，交易正在执行。 这是每笔交易的初始状态。

#### Partially Committed

当一个事务执行它的最终操作时，它被称为处于部分提交状态。

#### Committed

如果一个事务成功执行了它的所有操作，则称它已提交。 它的所有效果现在都永久地建立在数据库系统上。

#### Failed

如果数据库恢复系统所做的任何检查失败，则称该事务处于失败状态。 失败的交易不能再继续进行。

#### Aborted

如果任何检查失败并且事务已达到失败状态，则恢复管理器将回滚其对数据库的所有写操作，以使数据库恢复到事务执行之前的原始状态。
处于这种状态的交易被中止。

    数据库恢复模块可以在事务中止后选择以下两种操作之一：
      
      重启交易
      杀死交易

#### Terminated

如果没有任何回滚或事务来自已提交状态，则系统是一致的并为新事务做好准备，旧事务将终止。


<br>

---


## Distributed Transactions 分布式事务

`分布式事务`是跨两个或多个数据库执行的一组数据操作。 

它通常在通过网络连接的独立节点之间进行协调，但也可能跨越单个服务器上的多个数据库。


### 为什么需要分布式事务？

与单个数据库上的 ACID 事务不同，分布式事务涉及更改多个数据库上的数据。
因此，分布式事务处理更加复杂，因为数据库必须作为一个独立的单元来协调事务中更改的提交或回滚。

换句话说，所有节点都必须提交，或者所有节点都必须中止并且整个事务回滚。



### 一些流行的分布式事务解决方案



#### The two-phase commit (2PC)  两阶段提交 


`两阶段提交 (2PC) 协议`是一种`分布式算法`，它协调参与分布式事务的所有进程是提交还是中止（回滚）事务。

即使在许多临时系统故障的情况下，该协议也能实现其目标，因此被广泛使用。
但是，它无法适应所有可能的故障配置，并且在极少数情况下，需要手动干预来补救结果。

该协议需要一个`协调节点`，它基本上协调和监督不同节点之间的交易。
`协调器`试图分两个阶段在一组进程之间建立共识，因此得名。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/distributed-transactions/two-phase-commit.png)



> 两阶段提交包括以下阶段


- `准备阶段` Prepare phase


准备阶段涉及协调器节点从每个参与者节点收集共识。
除非每个节点都响应它们已准备好，否则事务将被中止。


- `提交阶段` Commit phase


如果所有参与者都向协调器响应他们已准备好，那么协调器将要求所有节点提交事务。 
如果发生故障，事务将被回滚



> 两阶段提交协议可能会出现以下问题：

    
    如果其中一个节点崩溃怎么办？

    如果协调器本身崩溃了怎么办？

    它是一个阻塞协议


####  Three-phase commit (3PC)  三阶段提交


`三阶段提交 (3PC)` 是两阶段提交的扩展，其中提交阶段分为两个阶段。 
这有助于解决两阶段提交协议中出现的阻塞问题


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/distributed-transactions/three-phase-commit.png)

> 三阶段提交包括以下阶段


- `Prepare phase` 准备阶段

此阶段与两阶段提交相同。

- `Pre-commit phase` 预提交阶段

协调器发出预提交消息，所有参与节点都必须确认它。 
如果参与者未能及时收到此消息，则交易将中止。

- `Commit phase` 提交阶段

这一步也类似于两阶段提交协议


> 为什么预提交阶段有帮助

如果在这个阶段找到了参与者节点，则意味着每个参与者都完成了第一阶段。 
准备阶段的完成是有保证的。 每个阶段现在都可以超时并避免无限期等待






#### Sagas


`saga` 是一系列`本地事务`。 

每个本地事务更新数据库并`发布消息或事件`以触发 `saga` 中的下一个本地事务。 

如果本地事务因为违反业务规则而失败，则` saga` 会执行一系列补偿事务，以撤消先前本地事务所做的更改。


![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/distributed-transactions/sagas.png)


协调的实现方式有两种：

    每个本地事务都会发布触发其他服务中本地事务的域事件。
    
    编排器告诉参与者要执行哪些本地事务。



问题

    Saga 模式特别难调试。
  
    参与者之间存在循环依赖的风险。
  
    缺乏参与者数据隔离带来了持久性挑战。
  
    测试很困难，因为所有服务都必须运行以模拟事务。


<br>

---


## Sharding 分片



### Data Partitioning 数据分区


`数据分区`是一种将数据库分解成许多较小部分的技术。

它是在多台机器上`拆分`数据库或表以提高数据库的可管理性、性能和可用性的过程。



#### 方法 Methods

有许多不同的方法可以用来决定如何将应用程序数据库分解为多个较小的数据库。

以下是各种大型应用程序使用的最流行的方法：


- `水平分区`（或`分片`）

在该策略中，我们根据分区键定义的取值范围`水平拆分表数据`。 它也称为`数据库分片 database sharding`。


- `垂直分区`

在垂直分区中，我们根据列对数据进行垂直分区。

我们将表划分为元素较少的相对较小的表，每个部分都存在于一个单独的分区中。






### 什么是分片？

分片是一种与水平分区相关的数据库架构模式，它是将一个表的行分成多个不同表的做法，称为分区或分片。

每个分区都有相同的模式和列，但也有共享数据的一个子集。 
同样，每个分区中保存的数据都是唯一的，并且独立于其他分区中保存的数据。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/sharding/sharding.png)

数据分片的理由是，在某个点之后，通过添加更多机器来水平扩展比通过添加强大的服务器来垂直扩展更便宜、更可行。
分片可以在应用程序或数据库级别实现


### 划分标准

有大量的标准可用于数据分区。 一些最常用的标准是：

####  Hash-Based 基于散列

该策略基于哈希算法将行划分为不同的分区，而不是基于连续索引对数据库行进行分组。

    这种方法的缺点是动态添加/删除数据库服务器变得昂贵。

####  List-Based 基于列表

在基于列表的分区中，每个分区都是根据列上的值列表而不是一组连续的值范围来定义和选择的。


#### Range Based  基于范围

范围分区根据分区键值的范围将数据映射到各个分区。 
换句话说，我们以这样一种方式对表进行分区，即每个分区都包含由分区键定义的给定范围内的行。

范围应该是连续的但不重叠，其中每个范围指定一个分区的非包含下限和上限。 
任何等于或高于范围上限的分区键值都将添加到下一个分区。


#### Composite 合成的

顾名思义，复合分区基于两种或多种分区技术对数据进行分区。 
这里我们首先使用一种技术对数据进行分区，然后使用相同或其他方法将每个分区进一步细分为子分区





### 分片优缺点




优点

    可用性：为分区数据库提供逻辑独立性，确保我们应用程序的高可用性。 在这里可以独立管理各个分区。

    可扩展性：证明可以通过跨多个分区分布数据来提高可扩展性。

    安全性：通过将敏感和非敏感数据存储在不同的分区中来帮助提高系统的安全性。 这可以为敏感数据提供更好的可管理性和安全性。

    查询性能：提高系统的性能。 现在系统不必查询整个数据库，而只需查询一个较小的分区。

    数据可管理性：将表和索引划分为更小且更易于管理的单元。


缺点

    
    复杂性：分片通常会增加系统的复杂性。

    跨分片连接：一旦数据库被分区并分布在多台机器上，执行跨多个数据库分片的连接通常是不可行的。 由于必须从多个服务器检索数据，因此此类连接的性能效率不高。

    重新平衡：如果数据分布不均匀或单个分片上有很多负载，在这种情况下，我们必须重新平衡我们的分片，以便请求尽可能平均地分布在分片之间。




什么时候使用分片

    
    利用现有硬件而不是高端机器。

    在不同的地理区域维护数据。

    通过添加更多分片来快速扩展。

    更好的性能，因为每台机器的负载都更少。

    当需要更多并发连接时。



<br>

---

## Consistent Hashing 一致性哈希



### 为什么要有 一致性哈希？

在传统的基于散列的分发方法中，我们使用散列函数来散列我们的分区键（即请求 ID 或 IP）。

然后，如果我们对节点（服务器或数据库）的总数使用模数。 这将为我们提供我们想要路由请求的节点。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/consistent-hashing/simple-hashing.png)



    key：请求ID或IP。
    
    H：哈希函数结果。
    
    N：节点总数。
    
    节点：请求将被路由到的节点。

这样做的问题是，如果我们添加或删除一个节点，它会导致 N 发生变化，
这意味着我们的映射策略将会中断，因为相同的请求现在将映射到不同的服务器。 
因此，大多数请求将需要重新分配，这是非常低效的。

我们希望在不同的节点之间统一分配请求，这样我们应该能够以最小的努力添加或删除节点。 
因此，我们需要一种不直接依赖于节点（或服务器）数量的分配方案，以便在添加或删除节点时，
需要重新定位的键的数量最少。

一致性哈希通过确保每次我们向上或向下扩展时，不必重新安排所有密钥或接触所有服务器，
从而解决了这个水平可扩展性问题。


### 一致性哈希 如何工作的

`Consistent Hashing` 是一种分布式哈希方案，它独立于分布式哈希表中的节点数量运行，
通过为它们分配一个抽象圆或哈希环上的位置。 



这允许服务器和对象在不影响整个系统的情况下进行扩展。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/consistent-hashing/consistent-hashing.png)

[>> Details consistent-hashing](https://kps.hashnode.dev/system-design-the-complete-course#heading-consistent-hashing)



<br>

---

## Database Federation 数据库联合


数据库联合（或功能分区）按功能拆分数据库。 使几个不同的物理数据库作为一个逻辑数据库出现在最终用户面前。

联合模式中的所有组件都通过一个或多个联合模式联系在一起，这些模式表达了整个联合模式数据的共性。
这些联合模式用于指定可由联合组件共享的信息，并为它们之间的通信提供公共基础。

![](https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-II/database-federation/database-federation.png)



联合数据库的一些关键特征：
    
    透明度：联合数据库掩盖了用户差异和底层数据源的实现。 因此，用户不需要知道数据存储在哪里。

    异质性：数据源可以在许多方面有所不同。 联合数据库系统可以处理不同的硬件、网络协议、数据模型等。

    可扩展性：可能需要新的资源来满足不断变化的业务需求。 一个好的联合数据库系统需要使添加新源变得容易。

    自治：联合数据库不会更改现有数据源，接口应保持不变。

    数据集成：联合数据库可以集成来自不同协议、数据库管理系统等的数据。

优点
    
    灵活的数据共享。

    数据库组件之间的自治。

    统一访问异构数据。

    应用程序与遗留数据库没有紧密耦合。


缺点：

    添加更多硬件和额外的复杂性。

    连接来自两个数据库的数据很复杂。

    对自主数据源的依赖。

    查询性能和可扩展性。


<br>

---


# Chapter III  服务架构
