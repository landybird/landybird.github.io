---
title: 后端存储小结 2                                             
description: 优化系统 + 提高性能
categories:
- 架构
tags:
- 架构   
---


#### `数据库超时`排查


系统基本架构


    系统  托管在 公有云 
    
    1  Nginx 作为前置网关 承接   前端所有请求
    
    2  后端 按照业务，划分了若干个 微服务 分别部署 
    
    3  数据保存在 MySQL 中
    
    4 部分数据用 Memcached  前置缓存
    
    >> 数据并没有按照微服务最佳实践的要求，做严格的划分和隔离，而是为了方便，存放在了一起
 
 
 
异常排查:


 
    1 随着访问量减少，系统能自动恢复，可以排除 后台服务被大量请求打死的可能性
        
         如果进程被打死了，一般是不会自动恢复
        
        
    >>> 重点放在mysql的请求上
    

![](https://landybird.github.io/landybird.github.io/assets/images/sql1.png)
    
    2  故障时段 MySQL 的 CPU 利用率一直是 100%。
       这种情况下，MySQL 基本上处于一个不可用的状态，执行所有的 SQL 都会超时
       
       MySQL 这种 CPU 利用率高的现象，绝大多数情况都是由  慢 SQL 导致的
       
       
     >>> 优先排查慢 SQL （慢 SQL 日志 -- SQL、执行次数、执行时长）
     
 
<br>
   
    3 定位慢SQL  
    
      排行榜的查询 TOP N 
        
        select fo.FollowId as vid, count(fo.id) as vcounts 
        from follow fo, user_info ui
        where fo.userid = ui.userid
        and fo.CreateTime between
        str_to_date(?, '%Y-%m-%d %H:%i:%s')
        and str_to_date(?, '%Y-%m-%d %H:%i:%s')
        and fo.IsDel = 0
        and ui.UserState = 0
        group by vid
        order by vcounts desc
        limit 0,10
    
    >>> 排行榜的查询，一定要做缓存

 
 缓存增加后
  

![](https://landybird.github.io/landybird.github.io/assets/images/sql2.png)
 
    4  CPU 利用率，以 20 分钟为周期，非常规律的波动
       总体的趋势与访问量正相关
       
       
    
    
![](https://landybird.github.io/landybird.github.io/assets/images/sql3.png)

   
    5  
       红线以下的部分，是正常处理日常访问请求的部分，它和访问量是 正相关 的。
       
       红线以上的部分，来自某一个以 20 分钟为周期的 定时任务，和访问量关系不大

    >>> 周期性的 定时任务 
    
    
    红线上部分:
        
        首页聚合了非常多的内容，像精选商品、标题图、排行榜、编辑推荐等等。
        
        这些内容包含了很多的数据库查询。
        
            首页做了一个整体的缓存，缓存的过期时间是  10 分钟
            
            需求不断变化，首页需要查询的内容越来越多，导致查询首页的全部内容越来越慢
            
            刷新一次缓存的时间要 15 分钟, 定时间隔为 10分钟, 所以下次刷新就推迟到了 20 分钟之后，这就导致了上面这个图中，红线以上每 20 分钟的规律波形


    红线下部分增加：
    
        由于缓存刷新慢，也会很多请求无法命中缓存，请求直接穿透缓存打到了数据库上面，
        这部分请求增加了很多 红线以下的部分
        
  
优化效果

![](https://landybird.github.io/landybird.github.io/assets/images/sql4.png)


 
> 注意点: 

关于 `sql`

    SQL 涉及到的表，它的数据规模 
    
    SQL 可能会遍历的数据量 
    
    尽量地避免写出慢 SQL

    

关于 `缓存`
    
    利用缓存减少数据库查询次数
    
    注意 缓存命中率，要尽量避免请求命中不了缓存，穿透到数据库上

    
    
> 架构层面改进的建议：

    1 上线一个定时监控和杀掉慢 SQL 的脚本
        
        每分钟执行一次，检测上一分钟内，有没有执行时间超过一分钟（这个阈值可以根据实际情况调整）的慢 SQL，如果发现，直接杀掉这个会话
        
    
    2 做一个简单的静态页面的首页作为  降级方案
    
        在 Nginx 上做一个策略，如果请求首页数据超时的时候，直接返回这个静态的首页作为替代。这样后续即使首页再出现任何的故障，也可以暂时降级，用静态首页替代。
        至少不会影响到用户使用其他功能
    
        

